<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Sound Calibration & Detection</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <h1>üéµ Machine Sound Calibration & Detection</h1>
        
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab(event, 'calibration')">üìä Calibration</button>
            <button class="tab-btn" onclick="switchTab(event, 'runcheck')">üîé Run Check</button>
            <button class="tab-btn" onclick="switchTab(event, 'livedetection')">üîç Live Detection</button>
            <button class="tab-btn" onclick="switchTab(event, 'profiles')">‚öôÔ∏è Profiles</button>
        </div>
        
        <!-- ===== CALIBRATION TAB (Per-Machine Listening) ===== -->
        <div id="calibration" class="tab-content active">
            <div class="status info" id="calibration-status">Click "Start Listening" on a machine to begin calibration</div>
            
            <h3>Start Listening ‚Äì Per Machine <span class="mode-badge idle" id="cal-mode-badge">IDLE</span></h3>
            <p style="color: #888; margin-bottom: 15px; font-size: 13px;">
                Each machine profile captures: Audio signature + Vibration pattern + Gas/air quality data
            </p>
            
            <!-- Machine Listen Buttons -->
            <div class="machines-grid" id="calibration-machines">
                <!-- Generated by JS -->
            </div>
            
            <!-- Calibration Control Panel -->
            <div class="control-panel" id="calibration-control-panel" style="display:none;">
                <h4 style="color: #22c55e; margin-bottom: 15px;">
                    üé§ Listening for: <span id="cal-active-machine">--</span>
                </h4>
                
                <div class="info-row">
                    <span class="info-label">Recording Duration:</span>
                    <span class="info-value" id="cal-duration">0s / 60s</span>
                </div>
                
                <!-- Data Collection Stats Grid -->
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-label">üéµ Audio Frames</div>
                        <div class="stat-value" id="cal-frames">0</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="cal-frames-progress" style="width: 0%;"></div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">üì≥ Vibration</div>
                        <div class="stat-value" id="cal-vib-count">0</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="cal-vib-progress" style="width: 0%;"></div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">üí® Gas Samples</div>
                        <div class="stat-value" id="cal-gas-count">0</div>
                        <div class="progress-bar">
                            <div class="progress-fill" id="cal-gas-progress" style="width: 0%;"></div>
                        </div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">üìä Avg Amplitude</div>
                        <div class="stat-value" id="cal-avg-amp">0.0</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">üîä Peak Frequency</div>
                        <div class="stat-value"><span id="cal-peak-freq">0</span><span class="stat-unit">Hz</span></div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">‚è±Ô∏è Time Remaining</div>
                        <div class="stat-value" id="cal-time-remain">60s</div>
                    </div>
                </div>
                
                <div class="timer" id="calibration-timer">0s</div>
                
                <div style="margin-top: 15px;">
                    <button id="calibration-stop" class="stop-btn" onclick="stopCalibration()">‚èπÔ∏è Stop Listening</button>
                    <button id="calibration-save" onclick="saveProfile()" disabled style="background: #3b82f6;">üíæ Save Profile</button>
                </div>
            </div>
            
            <!-- Waveform and Spectrum (shown when listening) -->
            <div id="calibration-waveform-container" style="display:none;">
                <h3>Live Audio Waveform:</h3>
                <canvas id="calibration-canvas"></canvas>
                
                <div class="chart-container">
                    <div class="chart-title">üìä Frequency Spectrum Analysis</div>
                    <canvas id="calibration-spectrum" class="spectrum-chart"></canvas>
                </div>
                
                <div class="chart-container">
                    <div class="chart-title">üìà Amplitude History (Last 60 samples)</div>
                    <canvas id="calibration-history" class="history-chart"></canvas>
                </div>
            </div>
        </div>
        
        <!-- ===== RUN CHECK TAB ===== -->
        <div id="runcheck" class="tab-content">
            <div class="status info" id="runcheck-status">Click "Run Check" to compare current audio against stored profiles</div>
            
            <h3>Run Check for Machine</h3>
            <p style="color: #888; margin-bottom: 20px; font-size: 13px;">
                Performs a one-time check to identify which machine (if any) matches the current sound.
                No live graphs ‚Äì logical check only.
            </p>
            
            <div class="control-panel">
                <button id="runcheck-btn" onclick="runCheck()" style="font-size: 16px; padding: 15px 30px;">
                    üîé Run Check for Machine
                </button>
                <button id="runcheck-stop" class="stop-btn" onclick="stopRunCheck()" disabled style="margin-left: 10px;">
                    ‚èπÔ∏è Stop
                </button>
                
                <div id="runcheck-progress" style="display: none; margin-top: 15px;">
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value" id="runcheck-progress-text">Analyzing...</span>
                    </div>
                </div>
            </div>
            
            <!-- Check Results (shown after check completes) -->
            <div class="check-results" id="runcheck-results" style="display: none;">
                <h4>üîç Check Results</h4>
                <div id="runcheck-results-list">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
        
        <!-- ===== LIVE DETECTION TAB (Main Dashboard) ===== -->
        <div id="livedetection" class="tab-content">
            <div class="status info" id="livedetection-status">Click "Start Machine Detecting" to begin live monitoring</div>
            
            <h3>Live Detection Dashboard <span class="mode-badge idle" id="live-mode-badge">IDLE</span></h3>
            
            <div style="margin-bottom: 20px;">
                <button id="live-start-btn" onclick="startLiveDetection()" style="font-size: 16px; padding: 15px 30px;">
                    üé§ Start Machine Detecting
                </button>
                <button id="live-stop-btn" class="stop-btn" onclick="stopLiveDetection()" disabled>
                    ‚èπÔ∏è Stop Detection
                </button>
            </div>
            
            <!-- Live Dashboard Grid (inactive until started) -->
            <div class="live-dashboard" id="live-dashboard">
                
                <!-- A. Machine Detection -->
                <div class="sensor-panel" id="panel-machine">
                    <h4>üîß Machine Detection</h4>
                    <div class="detected-machine-card no-detection" id="live-machine-card">
                        <div class="machine-name" id="live-detected-machine">--</div>
                        <div class="confidence" id="live-detection-confidence">Waiting...</div>
                    </div>
                    <div class="info-row" style="margin-top: 15px;">
                        <span class="info-label">Stable Machines:</span>
                        <span class="info-value" id="live-stable-machines">--</span>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-title">üîé Detection Confidence</div>
                        <canvas id="live-confidence-chart" class="mini-chart"></canvas>
                    </div>
                </div>
                
                <!-- B. Gas / Air Quality -->
                <div class="sensor-panel" id="panel-gas">
                    <h4>üí® Gas / Air Quality</h4>
                    <div class="gas-indicator safe" id="live-gas-indicator">
                        <div>
                            <div class="gas-value" id="live-gas-value">--</div>
                            <div class="gas-label">Raw Value</div>
                        </div>
                        <div style="flex: 1; text-align: right;">
                            <div style="font-size: 20px; font-weight: bold;" id="live-gas-status-text">--</div>
                            <div class="gas-label">Status</div>
                        </div>
                    </div>
                    <div class="gas-limits">
                        <span class="safe-limit">Safe: &lt; 300</span>
                        <span class="hazard-limit">Hazardous: &gt; 700</span>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-title">üìâ Gas Level History</div>
                        <canvas id="live-gas-chart" class="mini-chart"></canvas>
                    </div>
                </div>
                
                <!-- C. Vibration Monitoring -->
                <div class="sensor-panel" id="panel-vibration">
                    <h4>üì≥ Vibration Monitoring</h4>
                    <div class="value-large" id="live-vibration-value">--</div>
                    <div class="vibration-bar-container">
                        <div class="vibration-bar">
                            <div class="fill" id="live-vibration-bar" style="width: 0%;"></div>
                        </div>
                        <div class="vibration-label">
                            <span>0</span>
                            <span class="vibration-intensity low" id="live-vibration-intensity">--</span>
                            <span>100</span>
                        </div>
                    </div>
                    <div class="info-row" style="margin-top: 10px;">
                        <span class="info-label">Event Count:</span>
                        <span class="info-value" id="live-event-count">0</span>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-title">üìà Vibration Pattern</div>
                        <canvas id="live-vibration-chart" class="mini-chart"></canvas>
                    </div>
                </div>
                
                <!-- D. Audio Info -->
                <div class="sensor-panel" id="panel-audio-info">
                    <h4>üéµ Audio Analysis</h4>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="stat-label">Frequency</div>
                            <div class="stat-value"><span id="live-freq">--</span><span class="stat-unit">Hz</span></div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Amplitude</div>
                            <div class="stat-value" id="live-amp">--</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">Confidence</div>
                            <div class="stat-value" id="live-conf">--</div>
                        </div>
                    </div>
                    
                    <div class="chart-container">
                        <div class="chart-title">üéº Frequency Spectrum</div>
                        <canvas id="live-spectrum-chart" class="spectrum-chart"></canvas>
                    </div>
                </div>
                
                <!-- E. Live Waveform (spans full width) -->
                <div class="sensor-panel waveform-panel" id="panel-waveform">
                    <h4>üìä Live Audio Waveform</h4>
                    <canvas id="live-canvas"></canvas>
                    
                    <div class="stats-grid" style="margin-top: 15px;">
                        <div class="stat-card">
                            <div class="stat-label">üîä Peak Amplitude</div>
                            <div class="stat-value" id="live-peak-amp">0.0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">üîΩ Average Level</div>
                            <div class="stat-value" id="live-avg-amp">0.0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">üì° Samples/sec</div>
                            <div class="stat-value" id="live-sample-rate">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="stat-label">‚è±Ô∏è Running Time</div>
                            <div class="stat-value" id="live-runtime">0s</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- ===== PROFILES TAB ===== -->
        <div id="profiles" class="tab-content">
            <button onclick="loadProfiles()" style="margin-bottom: 20px;">üîÑ Refresh Profiles</button>
            <div id="profiles-list" class="profiles-list">
                <p style="color: #888;">Loading profiles...</p>
            </div>
        </div>
    </div>

    <script src="script.js"></script>
</body>
</html>
        let liveCanvasCtx = null;
        
        // Chart contexts
        let calibrationSpectrumCtx = null;
        let calibrationHistoryCtx = null;
        let liveSpectrumCtx = null;
        let liveConfidenceCtx = null;
        let liveGasCtx = null;
        let liveVibrationCtx = null;
        
        // Historical data for charts
        let amplitudeHistory = [];
        let frequencyHistory = [];
        let gasHistory = [];
        let vibrationHistory = [];
        let confidenceHistory = [];
        let liveStartTime = 0;
        let liveSampleCount = 0;
        
        // Stored profiles cache
        let machineProfiles = {};

        // ==========================================
        // INITIALIZATION
        // ==========================================
        window.addEventListener('load', function() {
            initializeCanvases();
            generateCalibrationButtons();
            loadProfiles();
            console.log("‚úÖ System initialized");
        });

        function initializeCanvases() {
            const calibCanvas = document.getElementById('calibration-canvas');
            const liveCanvas = document.getElementById('live-canvas');
            
            if (calibCanvas) {
                calibrationCanvasCtx = calibCanvas.getContext('2d');
                calibCanvas.width = calibCanvas.offsetWidth || 800;
                calibCanvas.height = calibCanvas.offsetHeight || 150;
            }
            
            // Calibration chart canvases
            const calibSpectrum = document.getElementById('calibration-spectrum');
            if (calibSpectrum) {
                calibrationSpectrumCtx = calibSpectrum.getContext('2d');
                calibSpectrum.width = calibSpectrum.offsetWidth || 800;
                calibSpectrum.height = 150;
            }
            
            const calibHistory = document.getElementById('calibration-history');
            if (calibHistory) {
                calibrationHistoryCtx = calibHistory.getContext('2d');
                calibHistory.width = calibHistory.offsetWidth || 800;
                calibHistory.height = 120;
            }
            
            if (liveCanvas) {
                liveCanvasCtx = liveCanvas.getContext('2d');
                liveCanvas.width = liveCanvas.offsetWidth || 800;
                liveCanvas.height = liveCanvas.offsetHeight || 150;
            }
            
            // Live detection chart canvases
            const liveSpectrum = document.getElementById('live-spectrum-chart');
            if (liveSpectrum) {
                liveSpectrumCtx = liveSpectrum.getContext('2d');
                liveSpectrum.width = liveSpectrum.offsetWidth || 400;
                liveSpectrum.height = 150;
            }
            
            const liveConfidence = document.getElementById('live-confidence-chart');
            if (liveConfidence) {
                liveConfidenceCtx = liveConfidence.getContext('2d');
                liveConfidence.width = liveConfidence.offsetWidth || 400;
                liveConfidence.height = 80;
            }
            
            const liveGas = document.getElementById('live-gas-chart');
            if (liveGas) {
                liveGasCtx = liveGas.getContext('2d');
                liveGas.width = liveGas.offsetWidth || 400;
                liveGas.height = 80;
            }
            
            const liveVibration = document.getElementById('live-vibration-chart');
            if (liveVibration) {
                liveVibrationCtx = liveVibration.getContext('2d');
                liveVibration.width = liveVibration.offsetWidth || 400;
                liveVibration.height = 80;
            }
        }

        function generateCalibrationButtons() {
            const container = document.getElementById('calibration-machines');
            const machines = ['machine_1', 'machine_2', 'machine_3'];
            
            container.innerHTML = machines.map(m => `
                <button class="listen-btn" id="listen-${m}" onclick="startListeningForMachine('${m}')" data-machine="${m}">
                    <span class="machine-name">${m.replace('_', ' ').toUpperCase()}</span>
                    <span class="profile-status" id="status-${m}">No profile</span>
                </button>
            `).join('');
        }

        // ==========================================
        // AUDIO INITIALIZATION
        // ==========================================
        async function initAudio() {
            try {
                // Check if already initialized and running
                if (audioContext && audioContext.state === 'running') {
                    console.log("‚úÖ Audio already initialized");
                    return true;
                }
                
                // Check if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    updateStatus('calibration', '‚ùå Your browser does not support microphone access. Try Chrome or Firefox.', 'error');
                    return false;
                }
                
                console.log("üé§ Requesting microphone permission...");
                updateStatus('calibration', 'üé§ Requesting microphone permission...', 'info');
                
                // Request microphone FIRST before creating AudioContext
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { 
                        echoCancellation: false, 
                        noiseSuppression: false, 
                        autoGainControl: false 
                    }
                });
                
                console.log("‚úÖ Microphone permission granted");
                
                // Create AudioContext after getting permission
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Resume AudioContext if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;
                analyser.minDecibels = -90;
                
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                console.log("‚úÖ Audio fully initialized");
                return true;
            } catch (error) {
                console.error("‚ùå Audio init failed:", error);
                
                // Provide specific error messages
                let errorMsg = 'Microphone error: ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMsg = '‚ùå Microphone permission denied. Click the üîí icon in address bar ‚Üí Allow microphone.';
                } else if (error.name === 'NotFoundError') {
                    errorMsg = '‚ùå No microphone found. Please connect a microphone.';
                } else if (error.name === 'NotReadableError') {
                    errorMsg = '‚ùå Microphone is in use by another app. Close other apps using the mic.';
                } else if (error.name === 'SecurityError') {
                    errorMsg = '‚ùå Microphone blocked. Page must be served over HTTPS or localhost.';
                } else {
                    errorMsg += error.message;
                }
                
                updateStatus('calibration', errorMsg, 'error');
                return false;
            }
        }

        // ==========================================
        // CALIBRATION MODE (PER MACHINE)
        // ==========================================
        async function startListeningForMachine(machineId) {
            if (isCalibrating) {
                updateStatus('calibration', '‚ö†Ô∏è Already listening! Stop first.', 'error');
                return;
            }
            
            const ok = await initAudio();
            if (!ok) return;
            
            selectedMachine = machineId;
            isCalibrating = true;
            calibrationData = [];
            calibrationFrameCount = 0;
            calibrationTimer = 0;
            calibrationVibrationSamples = [];
            calibrationGasSamples = [];
            amplitudeHistory = [];  // Reset amplitude history
            
            // Update UI
            document.getElementById('cal-mode-badge').textContent = 'LISTENING';
            document.getElementById('cal-mode-badge').className = 'mode-badge listening';
            document.getElementById('cal-active-machine').textContent = machineId.replace('_', ' ').toUpperCase();
            document.getElementById('calibration-control-panel').style.display = 'block';
            document.getElementById('calibration-waveform-container').style.display = 'block';
            document.getElementById('calibration-save').disabled = true;
            
            // Highlight active button
            document.querySelectorAll('.listen-btn').forEach(btn => {
                btn.classList.remove('listening');
                btn.disabled = true;
            });
            document.getElementById('listen-' + machineId).classList.add('listening');
            
            updateStatus('calibration', `üé§ Listening for ${machineId.replace('_', ' ').toUpperCase()}... Make steady sounds!`);
            
            // Start ESP32 polling during calibration
            startCalibrationESP32Polling();
            
            calibrationLoop();
        }

        function calibrationLoop() {
            if (!isCalibrating) return;
            
            const timeDomainData = new Uint8Array(analyser.frequencyBinCount);
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            
            analyser.getByteTimeDomainData(timeDomainData);
            analyser.getByteFrequencyData(frequencyData);
            
            let sum = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const val = (timeDomainData[i] - 128) / 128;
                sum += val * val;
            }
            const amplitude = Math.sqrt(sum / timeDomainData.length) * 100;
            
            let maxVal = 0, maxIndex = 0;
            for (let i = 1; i < frequencyData.length; i++) {
                if (frequencyData[i] > maxVal) {
                    maxVal = frequencyData[i];
                    maxIndex = i;
                }
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const dominantFreq = (maxIndex / frequencyData.length) * nyquist;
            const freqConfidence = maxVal / 255;
            
            const peaks = extractTopPeaks(frequencyData, nyquist, 5);
            
            calibrationFrameCount++;
            
            calibrationData.push({
                amplitude,
                peaks: peaks,
                timestamp: Date.now()
            });
            
            // Track amplitude history for charts
            amplitudeHistory.push(amplitude);
            if (amplitudeHistory.length > 60) amplitudeHistory.shift();
            
            // Calculate average amplitude
            const avgAmp = amplitudeHistory.reduce((a, b) => a + b, 0) / amplitudeHistory.length;
            
            // Update UI stats
            document.getElementById('cal-duration').textContent = `${Math.floor(calibrationTimer)}s / ${CALIBRATION_DURATION}s`;
            document.getElementById('cal-frames').textContent = calibrationFrameCount;
            document.getElementById('cal-vib-count').textContent = calibrationVibrationSamples.length;
            document.getElementById('cal-gas-count').textContent = calibrationGasSamples.length;
            document.getElementById('calibration-timer').textContent = `${Math.floor(calibrationTimer)}s`;
            document.getElementById('cal-avg-amp').textContent = avgAmp.toFixed(1);
            document.getElementById('cal-peak-freq').textContent = Math.round(dominantFreq);
            document.getElementById('cal-time-remain').textContent = Math.max(0, CALIBRATION_DURATION - Math.floor(calibrationTimer)) + 's';
            
            // Update progress bars
            const progress = (calibrationTimer / CALIBRATION_DURATION) * 100;
            document.getElementById('cal-frames-progress').style.width = progress + '%';
            document.getElementById('cal-vib-progress').style.width = progress + '%';
            document.getElementById('cal-gas-progress').style.width = progress + '%';
            
            // Draw visualizations
            drawWaveform(timeDomainData, calibrationCanvasCtx);
            if (calibrationSpectrumCtx) drawSpectrum(frequencyData, calibrationSpectrumCtx, nyquist);
            if (calibrationHistoryCtx) drawHistory(amplitudeHistory, calibrationHistoryCtx, 'Amplitude');
            
            calibrationTimer += 0.1;
            
            if (calibrationTimer >= CALIBRATION_DURATION) {
                stopCalibration();
            } else {
                setTimeout(calibrationLoop, 100);
            }
        }

        function startCalibrationESP32Polling() {
            if (calibrationESP32PollTimer) return;
            
            calibrationESP32PollTimer = setInterval(async () => {
                try {
                    const res = await fetch(BACKEND_URL + '/latest_esp32');
                    const data = await res.json();
                    console.log('ESP32 poll received:', data);
                    
                    if (data.vibration !== undefined) {
                        calibrationVibrationSamples.push(data.vibration);
                        document.getElementById('cal-vib-count').textContent = calibrationVibrationSamples.length;
                        console.log('Vibration samples now:', calibrationVibrationSamples.length);
                    }
                    if (data.gas_raw !== undefined) {
                        calibrationGasSamples.push({ raw: data.gas_raw, status: data.gas_status });
                        document.getElementById('cal-gas-count').textContent = calibrationGasSamples.length;
                        console.log('Gas samples now:', calibrationGasSamples.length);
                    }
                } catch (e) {
                    console.warn('ESP32 poll error:', e);
                }
            }, 500);
        }

        function stopCalibrationESP32Polling() {
            if (calibrationESP32PollTimer) {
                clearInterval(calibrationESP32PollTimer);
                calibrationESP32PollTimer = null;
            }
        }

        async function stopCalibration() {
            isCalibrating = false;
            stopCalibrationESP32Polling();
            
            // Update UI
            document.getElementById('cal-mode-badge').textContent = 'IDLE';
            document.getElementById('cal-mode-badge').className = 'mode-badge idle';
            document.querySelectorAll('.listen-btn').forEach(btn => {
                btn.classList.remove('listening');
                btn.disabled = false;
            });
            
            if (calibrationFrameCount > 0) {
                updateStatus('calibration', `üì§ Uploading ${calibrationData.length} frames...`, 'info');
                
                try {
                    const response = await fetch(BACKEND_URL + '/ingest', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            frames: calibrationData,
                            machine_id: selectedMachine,
                            mode: 'calibration',
                            store_all: true,
                            frames_captured: calibrationData.length
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.status === 'calibration_batch_saved') {
                        updateStatus('calibration', `‚úÖ Uploaded! ${result.frames_inserted} frames. Click Save Profile.`, 'success');
                        document.getElementById('calibration-save').disabled = false;
                    } else {
                        updateStatus('calibration', `Error: ${result.error || 'Unknown'}`, 'error');
                    }
                } catch (error) {
                    updateStatus('calibration', `Upload error: ${error.message}`, 'error');
                }
            } else {
                updateStatus('calibration', '‚ö†Ô∏è No frames captured. Try again.', 'error');
            }
        }

        async function saveProfile() {
            if (calibrationFrameCount < 10) {
                updateStatus('calibration', 'Need at least 10 frames!', 'error');
                return;
            }
            
            // Debug logging
            console.log('saveProfile called');
            console.log('calibrationVibrationSamples:', calibrationVibrationSamples);
            console.log('calibrationGasSamples:', calibrationGasSamples);
            
            try {
                const payload = { 
                    machine_id: selectedMachine,
                    vibration_samples: calibrationVibrationSamples,
                    gas_samples: calibrationGasSamples
                };
                console.log('Sending payload:', JSON.stringify(payload));
                
                const response = await fetch(BACKEND_URL + '/save_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });
                
                const result = await response.json();
                
                if (result.status === 'profile_saved') {
                    updateStatus('calibration', `‚úÖ Profile saved! Median: ${result.median_freq} Hz, ${result.bands_count} bands`, 'success');
                    document.getElementById('calibration-save').disabled = true;
                    loadProfiles();
                    
                    // Update button status
                    const statusEl = document.getElementById('status-' + selectedMachine);
                    if (statusEl) {
                        statusEl.textContent = '‚úì Profile saved';
                    }
                    document.getElementById('listen-' + selectedMachine).classList.add('has-profile');
                } else {
                    updateStatus('calibration', `Error: ${result.error}`, 'error');
                }
            } catch (error) {
                updateStatus('calibration', `Error: ${error.message}`, 'error');
            }
        }

        // ==========================================
        // RUN CHECK MODE (One-time check)
        // ==========================================
        async function runCheck() {
            const ok = await initAudio();
            if (!ok) return;
            
            isRunningCheck = true;
            runCheckBatch = [];
            
            document.getElementById('runcheck-btn').disabled = true;
            document.getElementById('runcheck-stop').disabled = false;
            document.getElementById('runcheck-progress').style.display = 'block';
            document.getElementById('runcheck-results').style.display = 'none';
            
            updateStatus('runcheck', 'üîé Analyzing audio for 3 seconds...', 'info');
            document.getElementById('runcheck-progress-text').textContent = 'Collecting samples...';
            
            // Collect for 3 seconds
            let checkDuration = 0;
            const checkLoop = () => {
                if (!isRunningCheck || checkDuration >= 3) {
                    finishRunCheck();
                    return;
                }
                
                const frequencyData = new Uint8Array(analyser.frequencyBinCount);
                analyser.getByteFrequencyData(frequencyData);
                
                const nyquist = audioContext.sampleRate / 2;
                const peaks = extractTopPeaks(frequencyData, nyquist, 5);
                
                if (peaks.length > 0) {
                    runCheckBatch.push({ peaks, timestamp: Date.now() });
                }
                
                checkDuration += 0.1;
                document.getElementById('runcheck-progress-text').textContent = `Collecting... ${checkDuration.toFixed(1)}s`;
                setTimeout(checkLoop, 100);
            };
            
            checkLoop();
        }

        function stopRunCheck() {
            isRunningCheck = false;
        }

        async function finishRunCheck() {
            isRunningCheck = false;
            document.getElementById('runcheck-btn').disabled = false;
            document.getElementById('runcheck-stop').disabled = true;
            
            if (runCheckBatch.length === 0) {
                updateStatus('runcheck', '‚ö†Ô∏è No audio detected. Make some sound!', 'error');
                document.getElementById('runcheck-progress').style.display = 'none';
                return;
            }
            
            document.getElementById('runcheck-progress-text').textContent = 'Analyzing against profiles...';
            
            try {
                // Send batch to backend for detection
                const response = await fetch(BACKEND_URL + '/ingest', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        frames: runCheckBatch.map(b => ({
                            amplitude: 1,
                            peaks: b.peaks,
                            timestamp: b.timestamp
                        })),
                        mode: 'live'
                    })
                });
                
                const result = await response.json();
                
                // Display results
                document.getElementById('runcheck-progress').style.display = 'none';
                document.getElementById('runcheck-results').style.display = 'block';
                
                const detectedRaw = result.running_machines_raw || [];
                const detectedStable = result.running_machines || [];
                const allMachines = result.all_machines || [];
                
                let html = '';
                if (allMachines.length === 0) {
                    html = '<p style="color: #888;">No machine profiles found. Calibrate first!</p>';
                } else {
                    allMachines.forEach(m => {
                        const isMatch = detectedRaw.includes(m);
                        html += `
                            <div class="check-result-item">
                                <span>${m.replace('_', ' ').toUpperCase()}</span>
                                <span class="${isMatch ? 'match' : 'no-match'}">
                                    ${isMatch ? '‚úì MATCH' : '‚úó No match'}
                                </span>
                            </div>
                        `;
                    });
                }
                
                document.getElementById('runcheck-results-list').innerHTML = html;
                
                if (detectedRaw.length > 0) {
                    updateStatus('runcheck', `‚úÖ Detected: ${detectedRaw.join(', ')}`, 'success');
                } else {
                    updateStatus('runcheck', 'No machines matched current audio.', 'info');
                }
                
            } catch (error) {
                updateStatus('runcheck', `Error: ${error.message}`, 'error');
                document.getElementById('runcheck-progress').style.display = 'none';
            }
        }

        // ==========================================
        // PROFILES
        // ==========================================
        async function loadProfiles() {
            try {
                const response = await fetch(BACKEND_URL + '/profiles');
                const profiles = await response.json();
                
                // Update cache
                machineProfiles = {};
                profiles.forEach(p => { machineProfiles[p.machine_id] = p; });
                
                // Update calibration button statuses
                ['machine_1', 'machine_2', 'machine_3'].forEach(m => {
                    const btn = document.getElementById('listen-' + m);
                    const status = document.getElementById('status-' + m);
                    if (btn && status) {
                        if (machineProfiles[m]) {
                            status.textContent = '‚úì Profile saved';
                            btn.classList.add('has-profile');
                        } else {
                            status.textContent = 'No profile';
                            btn.classList.remove('has-profile');
                        }
                    }
                });
                
                // Update profiles list
                const container = document.getElementById('profiles-list');
                
                if (profiles.length === 0) {
                    container.innerHTML = '<p style="color: #888;">No profiles trained yet.</p>';
                    return;
                }
                
                container.innerHTML = profiles.map(p => `
                    <div class="profile-card">
                        <div class="profile-header">
                            <span>${p.machine_id.replace('_', ' ').toUpperCase()}</span>
                            <button class="delete-btn" onclick="deleteProfile('${p.machine_id}')">üóëÔ∏è Delete</button>
                        </div>
                        
                        <!-- Audio Section -->
                        <div style="margin-top: 10px; padding: 10px; background: #0f1419; border-radius: 5px; border-left: 3px solid #3b82f6;">
                            <div style="color: #3b82f6; font-weight: bold; margin-bottom: 8px; font-size: 13px;">üîä Audio Signature</div>
                            <div class="profile-detail">
                                <span>Median Frequency:</span>
                                <strong>${p.median_freq} Hz</strong>
                            </div>
                            <div class="profile-detail">
                                <span>Overall IQR Range:</span>
                                <strong>${p.iqr_low} ‚Äì ${p.iqr_high} Hz</strong>
                            </div>
                            <div class="profile-detail">
                                <span>Frequency Bands:</span>
                                <strong>${p.bands_count || 0} bands</strong>
                            </div>
                            ${p.freq_bands && p.freq_bands.length > 0 ? `
                                <div style="margin-top: 8px; padding: 8px; background: #1a2332; border-radius: 4px;">
                                    <div style="color: #888; margin-bottom: 5px; font-size: 11px;">Detected Harmonic Bands:</div>
                                    ${p.freq_bands.map((b, i) => `
                                        <div style="font-size: 12px; color: #22c55e; padding: 2px 0;">
                                            Band ${i+1}: ${b.low.toFixed(0)} ‚Äì ${b.high.toFixed(0)} Hz (${b.samples} samples)
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                        
                        <!-- Vibration Section -->
                        <div style="margin-top: 10px; padding: 10px; background: #0f1419; border-radius: 5px; border-left: 3px solid #f59e0b;">
                            <div style="color: #f59e0b; font-weight: bold; margin-bottom: 8px; font-size: 13px;">üì≥ Vibration Pattern</div>
                            ${p.vibration_data ? `
                                <div class="profile-detail">
                                    <span>Samples Collected:</span>
                                    <strong>${p.vibration_data.samples}</strong>
                                </div>
                                <div class="profile-detail">
                                    <span>Vibration Detected:</span>
                                    <strong style="color: ${p.vibration_data.has_vibration ? '#22c55e' : '#888'};">
                                        ${p.vibration_data.vibration_percent}% of samples
                                    </strong>
                                </div>
                                <div class="profile-detail">
                                    <span>Status:</span>
                                    <strong style="color: ${p.vibration_data.has_vibration ? '#22c55e' : '#888'};">
                                        ${p.vibration_data.has_vibration ? '‚úì Machine Vibrates' : '‚úó No Vibration'}
                                    </strong>
                                </div>
                            ` : `
                                <div style="color: #666; font-size: 12px;">No vibration data collected</div>
                            `}
                        </div>
                        
                        <!-- Gas/Air Quality Section -->
                        <div style="margin-top: 10px; padding: 10px; background: #0f1419; border-radius: 5px; border-left: 3px solid ${
                            p.gas_data ? (p.gas_data.status === 'SAFE' ? '#22c55e' : p.gas_data.status === 'MODERATE' ? '#f59e0b' : p.gas_data.status === 'NO_DATA' ? '#666' : '#ef4444') : '#666'
                        };">
                            <div style="color: ${
                                p.gas_data ? (p.gas_data.status === 'SAFE' ? '#22c55e' : p.gas_data.status === 'MODERATE' ? '#f59e0b' : p.gas_data.status === 'NO_DATA' ? '#666' : '#ef4444') : '#666'
                            }; font-weight: bold; margin-bottom: 8px; font-size: 13px;">üí® Air Quality</div>
                            ${p.gas_data ? `
                                <div class="profile-detail">
                                    <span>Samples Collected:</span>
                                    <strong>${p.gas_data.valid_samples || p.gas_data.samples} / ${p.gas_data.samples}</strong>
                                </div>
                                <div class="profile-detail">
                                    <span>Average Gas Level:</span>
                                    <strong>${p.gas_data.avg_raw}</strong>
                                </div>
                                <div class="profile-detail">
                                    <span>Range:</span>
                                    <strong>${p.gas_data.min_raw} ‚Äì ${p.gas_data.max_raw}</strong>
                                </div>
                                <div class="profile-detail">
                                    <span>Status:</span>
                                    <strong style="color: ${p.gas_data.status === 'SAFE' ? '#22c55e' : p.gas_data.status === 'MODERATE' ? '#f59e0b' : p.gas_data.status === 'NO_DATA' ? '#666' : '#ef4444'};">
                                        ${p.gas_data.status === 'SAFE' ? '‚úì Safe (<800)' : p.gas_data.status === 'MODERATE' ? '‚ö†Ô∏è Moderate (800-2000)' : p.gas_data.status === 'NO_DATA' ? '‚ùì No valid readings' : 'üö® Hazardous (>2000)'}
                                    </strong>
                                </div>
                            ` : `
                                <div style="color: #666; font-size: 12px;">No gas data collected</div>
                            `}
                        </div>
                        
                        <div style="margin-top: 10px; font-size: 11px; color: #666;">
                            Created: ${p.created_at || 'Unknown'}
                        </div>
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading profiles:', error);
            }
        }

        async function deleteProfile(machineId) {
            if (!confirm(`Delete profile for ${machineId.replace('_', ' ').toUpperCase()}?`)) {
                return;
            }
            
            try {
                const response = await fetch(BACKEND_URL + '/delete_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ machine_id: machineId })
                });
                
                const result = await response.json();
                
                if (result.status === 'profile_deleted') {
                    alert(`‚úÖ Profile deleted: ${machineId}`);
                    loadProfiles();  // Refresh list
                } else {
                    alert(`‚ùå Error: ${result.error}`);
                }
            } catch (error) {
                alert(`Error deleting profile: ${error.message}`);
            }
        }

        // ==========================================
        // HELPERS & CHART DRAWING
        // ==========================================
        function drawWaveform(data, ctx) {
            if (!ctx) return;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            // Draw gradient waveform
            const gradient = ctx.createLinearGradient(0, 0, 0, ctx.canvas.height);
            gradient.addColorStop(0, '#22c55e');
            gradient.addColorStop(0.5, '#3b82f6');
            gradient.addColorStop(1, '#a855f7');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < data.length; i++) {
                const x = (i / data.length) * ctx.canvas.width;
                const y = ctx.canvas.height - ((data[i] / 255) * ctx.canvas.height);
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw center line
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(0, ctx.canvas.height / 2);
            ctx.lineTo(ctx.canvas.width, ctx.canvas.height / 2);
            ctx.stroke();
        }
        
        function drawSpectrum(frequencyData, ctx, nyquist) {
            if (!ctx) return;
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Draw bars with gradient
            const barWidth = width / frequencyData.length;
            const gradient = ctx.createLinearGradient(0, height, 0, 0);
            gradient.addColorStop(0, '#22c55e');
            gradient.addColorStop(0.5, '#3b82f6');
            gradient.addColorStop(1, '#ef4444');
            
            for (let i = 0; i < frequencyData.length; i++) {
                const barHeight = (frequencyData[i] / 255) * height;
                const x = i * barWidth;
                
                ctx.fillStyle = gradient;
                ctx.fillRect(x, height - barHeight, barWidth - 1, barHeight);
            }
            
            // Draw frequency labels
            ctx.fillStyle = '#666';
            ctx.font = '10px monospace';
            ctx.textAlign = 'left';
            const freqStep = Math.floor(nyquist / 4);
            for (let i = 0; i <= 4; i++) {
                const freq = i * freqStep;
                const x = (i / 4) * width;
                ctx.fillText(freq + 'Hz', x + 5, height - 5);
            }
        }
        
        function drawHistory(dataArray, ctx, label = '') {
            if (!ctx || dataArray.length === 0) return;
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            // Find max for scaling
            const max = Math.max(...dataArray, 1);
            
            // Draw gradient line
            const gradient = ctx.createLinearGradient(0, 0, width, 0);
            gradient.addColorStop(0, '#3b82f6');
            gradient.addColorStop(1, '#22c55e');
            
            ctx.strokeStyle = gradient;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < dataArray.length; i++) {
                const x = (i / (dataArray.length - 1)) * width;
                const y = height - ((dataArray[i] / max) * height * 0.9);
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.stroke();
            
            // Draw filled area
            ctx.lineTo(width, height);
            ctx.lineTo(0, height);
            ctx.closePath();
            const fillGradient = ctx.createLinearGradient(0, 0, 0, height);
            fillGradient.addColorStop(0, 'rgba(34, 197, 94, 0.3)');
            fillGradient.addColorStop(1, 'rgba(34, 197, 94, 0.05)');
            ctx.fillStyle = fillGradient;
            ctx.fill();
            
            // Draw grid lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= 4; i++) {
                const y = (i / 4) * height;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(width, y);
                ctx.stroke();
            }
            
            // Draw max value label
            ctx.fillStyle = '#666';
            ctx.font = '10px monospace';
            ctx.textAlign = 'right';
            ctx.fillText('Max: ' + max.toFixed(1), width - 5, 12);
        }
        
        function drawMiniLineChart(dataArray, ctx, color = '#22c55e', maxValue = null) {
            if (!ctx || dataArray.length === 0) return;
            const width = ctx.canvas.width;
            const height = ctx.canvas.height;
            
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, width, height);
            
            const max = maxValue || Math.max(...dataArray, 1);
            
            ctx.strokeStyle = color;
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < dataArray.length; i++) {
                const x = (i / Math.max(dataArray.length - 1, 1)) * width;
                const y = height - ((dataArray[i] / max) * height * 0.9) - height * 0.05;
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // ==========================================
        // PEAK EXTRACTION (NEW - CRITICAL FOR MULTI-MACHINE)
        // ==========================================
        /**
         * Extract top N peaks from frequency data.
         * Uses local maxima detection with minimum separation.
         * @param {Uint8Array} frequencyData - FFT frequency bins
         * @param {number} nyquist - Nyquist frequency (sampleRate/2)
         * @param {number} numPeaks - Number of peaks to extract (default 5)
         * @returns {Array} Array of {freq, amp} objects sorted by amplitude (descending)
         */
        function extractTopPeaks(frequencyData, nyquist, numPeaks = 5) {
            const peaks = [];
            const minSeparation = 5; // Minimum bin separation between peaks
            const minAmplitude = 10; // Minimum raw FFT value to consider (0-255) - lowered to capture quieter sounds
            
            // Find all local maxima
            for (let i = 2; i < frequencyData.length - 2; i++) {
                const val = frequencyData[i];
                
                // Skip if below minimum amplitude
                if (val < minAmplitude) continue;
                
                // Check if local maximum (higher than neighbors)
                if (val > frequencyData[i-1] && 
                    val > frequencyData[i+1] &&
                    val >= frequencyData[i-2] && 
                    val >= frequencyData[i+2]) {
                    
                    const freq = (i / frequencyData.length) * nyquist;
                    const amp = val / 255; // Normalize to 0-1
                    
                    peaks.push({ freq, amp, bin: i });
                }
            }
            
            // Sort by amplitude (descending)
            peaks.sort((a, b) => b.amp - a.amp);
            
            // Select top peaks with minimum separation
            const selectedPeaks = [];
            for (const peak of peaks) {
                // Check if far enough from already selected peaks
                let tooClose = false;
                for (const selected of selectedPeaks) {
                    if (Math.abs(peak.bin - selected.bin) < minSeparation) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    selectedPeaks.push({ freq: peak.freq, amp: peak.amp });
                    if (selectedPeaks.length >= numPeaks) break;
                }
            }
            
            return selectedPeaks;
        }

        function switchTab(event, tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            
            document.getElementById(tab).classList.add('active');
            event.target.classList.add('active');
            
            // Initialize canvas when switching to live detection
            if (tab === 'livedetection') {
                setTimeout(initializeCanvases, 100);
            }
        }

        function updateStatus(tab, message, type = 'info') {
            const el = document.getElementById(tab + '-status');
            if (el) {
                el.textContent = message;
                el.className = 'status ' + type;
            }
        }

        // ==========================================
        // LIVE DETECTION MODE (Main Dashboard)
        // ==========================================
        async function startLiveDetection() {
            const ok = await initAudio();
            if (!ok) {
                updateStatus('livedetection', '‚ùå Microphone access required', 'error');
                return;
            }
            
            isLiveDetecting = true;
            liveBatch = [];
            liveBatchTimer = 0;
            
            // Reset tracking variables
            amplitudeHistory = [];
            frequencyHistory = [];
            gasHistory = [];
            vibrationHistory = [];
            confidenceHistory = [];
            liveStartTime = Date.now();
            liveSampleCount = 0;
            
            // Update UI
            document.getElementById('live-mode-badge').textContent = 'DETECTING';
            document.getElementById('live-mode-badge').className = 'mode-badge detecting';
            document.getElementById('live-start-btn').disabled = true;
            document.getElementById('live-stop-btn').disabled = false;
            
            updateStatus('livedetection', 'üé§ Live detection running...', 'success');
            
            // Start ESP32 polling for live mode
            startLiveESP32Polling();
            
            // Start audio detection loop
            liveDetectionLoop();
        }

        function liveDetectionLoop() {
            if (!isLiveDetecting) return;
            
            const timeDomainData = new Uint8Array(analyser.frequencyBinCount);
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            
            analyser.getByteTimeDomainData(timeDomainData);
            analyser.getByteFrequencyData(frequencyData);
            
            let sum = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const val = (timeDomainData[i] - 128) / 128;
                sum += val * val;
            }
            const amplitude = Math.sqrt(sum / timeDomainData.length) * 100;
            
            let maxVal = 0, maxIndex = 0;
            for (let i = 1; i < frequencyData.length; i++) {
                if (frequencyData[i] > maxVal) {
                    maxVal = frequencyData[i];
                    maxIndex = i;
                }
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const dominantFreq = (maxIndex / frequencyData.length) * nyquist;
            const freqConfidence = maxVal / 255;
            
            const peaks = extractTopPeaks(frequencyData, nyquist, 5);
            
            // Track history
            liveSampleCount++;
            amplitudeHistory.push(amplitude);
            if (amplitudeHistory.length > 60) amplitudeHistory.shift();
            
            frequencyHistory.push(dominantFreq);
            if (frequencyHistory.length > 60) frequencyHistory.shift();
            
            confidenceHistory.push(freqConfidence);
            if (confidenceHistory.length > 30) confidenceHistory.shift();
            
            // Calculate stats
            const peakAmp = Math.max(...amplitudeHistory);
            const avgAmp = amplitudeHistory.reduce((a, b) => a + b, 0) / amplitudeHistory.length;
            const runningTime = Math.floor((Date.now() - liveStartTime) / 1000);
            const sampleRate = Math.floor(liveSampleCount / Math.max(runningTime, 1));
            
            // Collect frame
            liveBatch.push({
                amplitude,
                peaks: peaks,
                dominant_freq: dominantFreq,
                freq_confidence: freqConfidence,
                timestamp: Date.now()
            });
            
            // Update audio UI
            document.getElementById('live-freq').textContent = dominantFreq.toFixed(1);
            document.getElementById('live-amp').textContent = amplitude.toFixed(2);
            document.getElementById('live-conf').textContent = freqConfidence.toFixed(3);
            document.getElementById('live-peak-amp').textContent = peakAmp.toFixed(1);
            document.getElementById('live-avg-amp').textContent = avgAmp.toFixed(1);
            document.getElementById('live-sample-rate').textContent = sampleRate;
            document.getElementById('live-runtime').textContent = runningTime + 's';
            
            // Draw visualizations
            if (liveCanvasCtx) drawWaveform(timeDomainData, liveCanvasCtx);
            if (liveSpectrumCtx) drawSpectrum(frequencyData, liveSpectrumCtx, nyquist);
            if (liveConfidenceCtx) drawMiniLineChart(confidenceHistory, liveConfidenceCtx, '#3b82f6', 1);
            
            // Send batch every 500ms
            liveBatchTimer += 0.1;
            if (liveBatchTimer >= 0.5) {
                if (liveBatch.length > 0) {
                    sendLiveBatch();
                }
                liveBatch = [];
                liveBatchTimer = 0;
            }
            
            setTimeout(liveDetectionLoop, 100);
        }

        async function sendLiveBatch() {
            try {
                const response = await fetch(BACKEND_URL + '/ingest', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        frames: liveBatch,
                        mode: 'live'
                    })
                });
                
                const data = await response.json();
                
                // Update machine detection display
                const card = document.getElementById('live-machine-card');
                const nameEl = document.getElementById('live-detected-machine');
                const confEl = document.getElementById('live-detection-confidence');
                const stableEl = document.getElementById('live-stable-machines');
                
                const detected = data.running_machines_raw || [];
                const stable = data.running_machines || [];
                
                if (stable.length > 0) {
                    nameEl.textContent = stable.map(m => m.replace('_', ' ').toUpperCase()).join(', ');
                    confEl.textContent = 'Stable detection';
                    card.className = 'detected-machine-card detected';
                } else if (detected.length > 0) {
                    nameEl.textContent = detected.map(m => m.replace('_', ' ').toUpperCase()).join(', ');
                    confEl.textContent = 'Detecting...';
                    card.className = 'detected-machine-card';
                } else {
                    nameEl.textContent = 'No machine detected';
                    confEl.textContent = 'Listening...';
                    card.className = 'detected-machine-card no-detection';
                }
                
                stableEl.textContent = stable.length > 0 ? stable.join(', ') : '--';
                
            } catch (err) {
                console.warn('Live batch error:', err);
            }
        }

        function startLiveESP32Polling() {
            if (liveESP32PollTimer) return;
            
            fetchLiveESP32Data();
            liveESP32PollTimer = setInterval(fetchLiveESP32Data, 1000);
        }

        function stopLiveESP32Polling() {
            if (liveESP32PollTimer) {
                clearInterval(liveESP32PollTimer);
                liveESP32PollTimer = null;
            }
        }

        async function fetchLiveESP32Data() {
            try {
                const res = await fetch(BACKEND_URL + '/latest_esp32');
                const data = await res.json();
                
                // Update vibration display
                const vibValue = data.vibration || 0;
                document.getElementById('live-vibration-value').textContent = vibValue > 0 ? 'ON' : 'OFF';
                
                const vibPercent = Math.min(vibValue * 100, 100);
                document.getElementById('live-vibration-bar').style.width = vibPercent + '%';
                
                const intensityEl = document.getElementById('live-vibration-intensity');
                if (vibValue > 0.7) {
                    intensityEl.textContent = 'HIGH';
                    intensityEl.className = 'vibration-intensity high';
                } else if (vibValue > 0.3) {
                    intensityEl.textContent = 'MEDIUM';
                    intensityEl.className = 'vibration-intensity medium';
                } else {
                    intensityEl.textContent = 'LOW';
                    intensityEl.className = 'vibration-intensity low';
                }
                
                document.getElementById('live-event-count').textContent = data.event_count || 0;
                
                // Track vibration history
                vibrationHistory.push(vibValue * 100);
                if (vibrationHistory.length > 30) vibrationHistory.shift();
                
                // Update gas display
                const gasRaw = data.gas_raw || 0;
                const gasStatus = data.gas_status || 'UNKNOWN';
                
                document.getElementById('live-gas-value').textContent = gasRaw;
                document.getElementById('live-gas-status-text').textContent = gasStatus;
                
                // Track gas history
                gasHistory.push(gasRaw);
                if (gasHistory.length > 30) gasHistory.shift();
                
                const gasIndicator = document.getElementById('live-gas-indicator');
                gasIndicator.className = 'gas-indicator';
                
                if (gasRaw > GAS_HAZARD_LIMIT || gasStatus === 'RISK' || gasStatus === 'DANGER') {
                    gasIndicator.classList.add('hazardous');
                } else if (gasRaw > GAS_SAFE_LIMIT || gasStatus === 'WARNING') {
                    gasIndicator.classList.add('warning');
                } else {
                    gasIndicator.classList.add('safe');
                }
                
                // Update charts
                if (liveGasCtx) drawMiniLineChart(gasHistory, liveGasCtx, '#f59e0b', 1000);
                if (liveVibrationCtx) drawMiniLineChart(vibrationHistory, liveVibrationCtx, '#ef4444', 100);
                
            } catch (err) {
                console.warn('ESP32 fetch error:', err);
            }
        }

        function stopLiveDetection() {
            isLiveDetecting = false;
            liveBatch = [];
            liveBatchTimer = 0;
            
            stopLiveESP32Polling();
            
            document.getElementById('live-mode-badge').textContent = 'IDLE';
            document.getElementById('live-mode-badge').className = 'mode-badge idle';
            document.getElementById('live-start-btn').disabled = false;
            document.getElementById('live-stop-btn').disabled = true;
            
            updateStatus('livedetection', 'Detection stopped.', 'info');
        }
    </script>
</body>
</html>