<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Sound Calibration & Detection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0f1419;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #22c55e;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab-btn.active {
            color: #22c55e;
            border-bottom-color: #22c55e;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .machines-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .machine-btn {
            padding: 20px;
            background: #1a2332;
            border: 2px solid #333;
            color: #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .machine-btn:hover {
            border-color: #22c55e;
            background: #1f2a38;
        }
        
        .machine-btn.selected {
            background: #22c55e;
            color: #000;
            border-color: #22c55e;
        }
        
        .control-panel {
            background: #1a2332;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 10px;
            background: #0f1419;
            border-radius: 5px;
        }
        
        .info-label {
            font-weight: bold;
            color: #888;
        }
        
        .info-value {
            color: #22c55e;
            font-weight: bold;
            font-size: 18px;
        }
        
        button {
            padding: 10px 20px;
            background: #22c55e;
            border: none;
            color: #000;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
            margin-right: 10px;
        }
        
        button:hover {
            background: #1ea850;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .stop-btn {
            background: #ef4444;
            color: white;
        }
        
        .stop-btn:hover {
            background: #dc2626;
        }
        
        canvas {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .status.info {
            background: #1e3a8a;
            color: #93c5fd;
        }
        
        .status.success {
            background: #166534;
            color: #86efac;
        }
        
        .status.error {
            background: #7f1d1d;
            color: #fca5a5;
        }
        
        .profiles-list {
            display: grid;
            gap: 15px;
        }
        
        .profile-card {
            background: #1a2332;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #22c55e;
        }
        
        .profile-header {
            font-size: 18px;
            font-weight: bold;
            color: #22c55e;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .delete-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .delete-btn:hover {
            background: #dc2626;
        }
        
        .profile-detail {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 5px;
        }
        
        .detection-status {
            font-size: 24px;
            font-weight: bold;
            padding: 20px;
            text-align: center;
            background: #1a2332;
            border-radius: 8px;
            margin-bottom: 20px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .detection-status.active {
            background: #166534;
            color: #86efac;
        }
        
        .timer {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            color: #22c55e;
            margin: 20px 0;
        }
        
        h3 {
            margin-top: 20px;
            margin-bottom: 15px;
            color: #e0e0e0;
        }
        
        /* ========== NEW UI STYLES ========== */
        
        /* Mode indicator badge */
        .mode-badge {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: bold;
            text-transform: uppercase;
            margin-left: 10px;
        }
        .mode-badge.listening {
            background: #22c55e;
            color: #000;
            animation: pulse 1.5s infinite;
        }
        .mode-badge.idle {
            background: #374151;
            color: #9ca3af;
        }
        .mode-badge.detecting {
            background: #3b82f6;
            color: #fff;
            animation: pulse 1.5s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        /* Listen button per machine */
        .listen-btn {
            padding: 15px 20px;
            background: #1a2332;
            border: 2px solid #333;
            color: #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
        }
        .listen-btn:hover:not(:disabled) {
            border-color: #22c55e;
            background: #1f2a38;
        }
        .listen-btn.listening {
            background: #166534;
            border-color: #22c55e;
            color: #86efac;
        }
        .listen-btn.has-profile {
            border-left: 4px solid #22c55e;
        }
        .listen-btn .machine-name {
            font-size: 16px;
        }
        .listen-btn .profile-status {
            font-size: 11px;
            color: #888;
        }
        .listen-btn.has-profile .profile-status {
            color: #22c55e;
        }
        
        /* Live dashboard grid */
        .live-dashboard {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }
        @media (max-width: 900px) {
            .live-dashboard {
                grid-template-columns: 1fr;
            }
        }
        
        /* Sensor panel card */
        .sensor-panel {
            background: #1a2332;
            border-radius: 8px;
            padding: 20px;
            border-left: 4px solid #333;
        }
        .sensor-panel.active {
            border-left-color: #22c55e;
        }
        .sensor-panel h4 {
            margin: 0 0 15px 0;
            color: #888;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        .sensor-panel .value-large {
            font-size: 36px;
            font-weight: bold;
            color: #22c55e;
            margin-bottom: 10px;
        }
        
        /* Gas status indicator */
        .gas-indicator {
            display: flex;
            align-items: center;
            gap: 15px;
            padding: 15px;
            border-radius: 8px;
            background: #0f1419;
        }
        .gas-indicator .gas-value {
            font-size: 24px;
            font-weight: bold;
        }
        .gas-indicator .gas-label {
            font-size: 12px;
            color: #888;
        }
        .gas-indicator.safe {
            border: 2px solid #22c55e;
        }
        .gas-indicator.safe .gas-value { color: #22c55e; }
        .gas-indicator.warning {
            border: 2px solid #eab308;
        }
        .gas-indicator.warning .gas-value { color: #eab308; }
        .gas-indicator.hazardous {
            border: 2px solid #ef4444;
            background: #1f0a0a;
        }
        .gas-indicator.hazardous .gas-value { color: #ef4444; }
        
        /* Vibration bar */
        .vibration-bar-container {
            background: #0f1419;
            border-radius: 8px;
            padding: 15px;
            margin-top: 10px;
        }
        .vibration-bar {
            height: 20px;
            background: #333;
            border-radius: 4px;
            overflow: hidden;
            margin-bottom: 8px;
        }
        .vibration-bar .fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #eab308, #ef4444);
            transition: width 0.2s;
            border-radius: 4px;
        }
        .vibration-label {
            display: flex;
            justify-content: space-between;
            font-size: 12px;
            color: #888;
        }
        .vibration-intensity {
            font-weight: bold;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 11px;
        }
        .vibration-intensity.low { background: #166534; color: #86efac; }
        .vibration-intensity.medium { background: #854d0e; color: #fde047; }
        .vibration-intensity.high { background: #7f1d1d; color: #fca5a5; }
        
        /* Machine detection result card */
        .detected-machine-card {
            background: #0f1419;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            min-height: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            border: 2px solid #333;
        }
        .detected-machine-card.detected {
            border-color: #22c55e;
            background: #0a1f0a;
        }
        .detected-machine-card .machine-name {
            font-size: 28px;
            font-weight: bold;
            color: #22c55e;
        }
        .detected-machine-card .confidence {
            font-size: 14px;
            color: #888;
            margin-top: 5px;
        }
        .detected-machine-card.no-detection .machine-name {
            color: #666;
            font-size: 18px;
        }
        
        /* Run check results */
        .check-results {
            background: #1a2332;
            border-radius: 8px;
            padding: 20px;
            margin-top: 20px;
        }
        .check-results h4 {
            margin: 0 0 15px 0;
            color: #e0e0e0;
        }
        .check-result-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            background: #0f1419;
            border-radius: 5px;
            margin-bottom: 8px;
        }
        .check-result-item .match {
            color: #22c55e;
            font-weight: bold;
        }
        .check-result-item .no-match {
            color: #666;
        }
        
        /* Calibration data collection indicator */
        .data-collection {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-top: 15px;
        }
        .data-item {
            background: #0f1419;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .data-item .label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
        }
        .data-item .count {
            font-size: 18px;
            font-weight: bold;
            color: #22c55e;
        }
        .data-item.inactive .count {
            color: #666;
        }
        
        /* Audio waveform panel */
        .waveform-panel {
            grid-column: 1 / -1;
        }
        .waveform-panel canvas {
            height: 150px;
        }
        
        /* Inactive/disabled panel state */
        .panel-inactive {
            opacity: 0.5;
            pointer-events: none;
        }
        .panel-inactive::after {
            content: 'Click "Start Machine Detecting" to activate';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #666;
            font-size: 12px;
            text-align: center;
        }
        
        /* Gas limit markers */
        .gas-limits {
            display: flex;
            justify-content: space-between;
            font-size: 11px;
            color: #666;
            margin-top: 5px;
            padding: 0 5px;
        }
        .gas-limits span {
            padding: 2px 6px;
            border-radius: 3px;
        }
        .gas-limits .safe-limit { background: #052e16; color: #22c55e; }
        .gas-limits .hazard-limit { background: #450a0a; color: #ef4444; }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Machine Sound Calibration & Detection</h1>
        
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab(event, 'calibration')">üìä Calibration</button>
            <button class="tab-btn" onclick="switchTab(event, 'runcheck')">üîé Run Check</button>
            <button class="tab-btn" onclick="switchTab(event, 'livedetection')">üîç Live Detection</button>
            <button class="tab-btn" onclick="switchTab(event, 'profiles')">‚öôÔ∏è Profiles</button>
        </div>
        
        <!-- ===== CALIBRATION TAB (Per-Machine Listening) ===== -->
        <div id="calibration" class="tab-content active">
            <div class="status info" id="calibration-status">Click "Start Listening" on a machine to begin calibration</div>
            
            <h3>Start Listening ‚Äì Per Machine <span class="mode-badge idle" id="cal-mode-badge">IDLE</span></h3>
            <p style="color: #888; margin-bottom: 15px; font-size: 13px;">
                Each machine profile captures: Audio signature + Vibration pattern + Gas/air quality data
            </p>
            
            <!-- Machine Listen Buttons -->
            <div class="machines-grid" id="calibration-machines">
                <!-- Generated by JS -->
            </div>
            
            <!-- Calibration Control Panel -->
            <div class="control-panel" id="calibration-control-panel" style="display:none;">
                <h4 style="color: #22c55e; margin-bottom: 15px;">
                    üé§ Listening for: <span id="cal-active-machine">--</span>
                </h4>
                
                <div class="info-row">
                    <span class="info-label">Recording Duration:</span>
                    <span class="info-value" id="cal-duration">0s / 60s</span>
                </div>
                
                <!-- Data Collection Indicators -->
                <div class="data-collection">
                    <div class="data-item" id="cal-audio-data">
                        <div class="label">üéµ Audio Frames</div>
                        <div class="count" id="cal-frames">0</div>
                    </div>
                    <div class="data-item" id="cal-vibration-data">
                        <div class="label">üì≥ Vibration Samples</div>
                        <div class="count" id="cal-vib-count">0</div>
                    </div>
                    <div class="data-item" id="cal-gas-data">
                        <div class="label">üí® Gas Samples</div>
                        <div class="count" id="cal-gas-count">0</div>
                    </div>
                </div>
                
                <div class="timer" id="calibration-timer">0s</div>
                
                <div style="margin-top: 15px;">
                    <button id="calibration-stop" class="stop-btn" onclick="stopCalibration()">‚èπÔ∏è Stop Listening</button>
                    <button id="calibration-save" onclick="saveProfile()" disabled style="background: #3b82f6;">üíæ Save Profile</button>
                </div>
            </div>
            
            <!-- Waveform (only shown when listening) -->
            <div id="calibration-waveform-container" style="display:none;">
                <h3>Live Audio Waveform:</h3>
                <canvas id="calibration-canvas"></canvas>
            </div>
        </div>
        
        <!-- ===== RUN CHECK TAB ===== -->
        <div id="runcheck" class="tab-content">
            <div class="status info" id="runcheck-status">Click "Run Check" to compare current audio against stored profiles</div>
            
            <h3>Run Check for Machine</h3>
            <p style="color: #888; margin-bottom: 20px; font-size: 13px;">
                Performs a one-time check to identify which machine (if any) matches the current sound.
                No live graphs ‚Äì logical check only.
            </p>
            
            <div class="control-panel">
                <button id="runcheck-btn" onclick="runCheck()" style="font-size: 16px; padding: 15px 30px;">
                    üîé Run Check for Machine
                </button>
                <button id="runcheck-stop" class="stop-btn" onclick="stopRunCheck()" disabled style="margin-left: 10px;">
                    ‚èπÔ∏è Stop
                </button>
                
                <div id="runcheck-progress" style="display: none; margin-top: 15px;">
                    <div class="info-row">
                        <span class="info-label">Status:</span>
                        <span class="info-value" id="runcheck-progress-text">Analyzing...</span>
                    </div>
                </div>
            </div>
            
            <!-- Check Results (shown after check completes) -->
            <div class="check-results" id="runcheck-results" style="display: none;">
                <h4>üîç Check Results</h4>
                <div id="runcheck-results-list">
                    <!-- Populated by JS -->
                </div>
            </div>
        </div>
        
        <!-- ===== LIVE DETECTION TAB (Main Dashboard) ===== -->
        <div id="livedetection" class="tab-content">
            <div class="status info" id="livedetection-status">Click "Start Machine Detecting" to begin live monitoring</div>
            
            <h3>Live Detection Dashboard <span class="mode-badge idle" id="live-mode-badge">IDLE</span></h3>
            
            <div style="margin-bottom: 20px;">
                <button id="live-start-btn" onclick="startLiveDetection()" style="font-size: 16px; padding: 15px 30px;">
                    üé§ Start Machine Detecting
                </button>
                <button id="live-stop-btn" class="stop-btn" onclick="stopLiveDetection()" disabled>
                    ‚èπÔ∏è Stop Detection
                </button>
            </div>
            
            <!-- Live Dashboard Grid (inactive until started) -->
            <div class="live-dashboard" id="live-dashboard">
                
                <!-- A. Machine Detection -->
                <div class="sensor-panel" id="panel-machine">
                    <h4>üîß Machine Detection</h4>
                    <div class="detected-machine-card no-detection" id="live-machine-card">
                        <div class="machine-name" id="live-detected-machine">--</div>
                        <div class="confidence" id="live-detection-confidence">Waiting...</div>
                    </div>
                    <div class="info-row" style="margin-top: 15px;">
                        <span class="info-label">Stable Machines:</span>
                        <span class="info-value" id="live-stable-machines">--</span>
                    </div>
                </div>
                
                <!-- B. Gas / Air Quality -->
                <div class="sensor-panel" id="panel-gas">
                    <h4>üí® Gas / Air Quality</h4>
                    <div class="gas-indicator safe" id="live-gas-indicator">
                        <div>
                            <div class="gas-value" id="live-gas-value">--</div>
                            <div class="gas-label">Raw Value</div>
                        </div>
                        <div style="flex: 1; text-align: right;">
                            <div style="font-size: 20px; font-weight: bold;" id="live-gas-status-text">--</div>
                            <div class="gas-label">Status</div>
                        </div>
                    </div>
                    <div class="gas-limits">
                        <span class="safe-limit">Safe: &lt; 300</span>
                        <span class="hazard-limit">Hazardous: &gt; 700</span>
                    </div>
                </div>
                
                <!-- C. Vibration Monitoring -->
                <div class="sensor-panel" id="panel-vibration">
                    <h4>üì≥ Vibration Monitoring</h4>
                    <div class="value-large" id="live-vibration-value">--</div>
                    <div class="vibration-bar-container">
                        <div class="vibration-bar">
                            <div class="fill" id="live-vibration-bar" style="width: 0%;"></div>
                        </div>
                        <div class="vibration-label">
                            <span>0</span>
                            <span class="vibration-intensity low" id="live-vibration-intensity">--</span>
                            <span>100</span>
                        </div>
                    </div>
                    <div class="info-row" style="margin-top: 10px;">
                        <span class="info-label">Event Count:</span>
                        <span class="info-value" id="live-event-count">0</span>
                    </div>
                </div>
                
                <!-- D. Audio Info -->
                <div class="sensor-panel" id="panel-audio-info">
                    <h4>üéµ Audio Analysis</h4>
                    <div class="info-row">
                        <span class="info-label">Dominant Frequency:</span>
                        <span class="info-value" id="live-freq">-- Hz</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Amplitude:</span>
                        <span class="info-value" id="live-amp">--</span>
                    </div>
                    <div class="info-row">
                        <span class="info-label">Confidence:</span>
                        <span class="info-value" id="live-conf">--</span>
                    </div>
                </div>
                
                <!-- E. Live Waveform (spans full width) -->
                <div class="sensor-panel waveform-panel" id="panel-waveform">
                    <h4>üìä Live Audio Waveform</h4>
                    <canvas id="live-canvas"></canvas>
                </div>
            </div>
        </div>
        
        <!-- ===== PROFILES TAB ===== -->
        <div id="profiles" class="tab-content">
            <button onclick="loadProfiles()" style="margin-bottom: 20px;">üîÑ Refresh Profiles</button>
            <div id="profiles-list" class="profiles-list">
                <p style="color: #888;">Loading profiles...</p>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        const BACKEND_URL = `${window.location.origin}`;
        const CALIBRATION_DURATION = 60;
        const AMPLITUDE_THRESHOLD = 0.5;
        const CONFIDENCE_THRESHOLD = 0.08;
        
        // Gas thresholds for display
        const GAS_SAFE_LIMIT = 300;
        const GAS_HAZARD_LIMIT = 700;
        
        // ==========================================
        // STATE VARIABLES
        // ==========================================
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        
        // Calibration state
        let isCalibrating = false;
        let calibrationData = [];
        let calibrationTimer = 0;
        let calibrationFrameCount = 0;
        let selectedMachine = null;
        let calibrationVibrationSamples = [];
        let calibrationGasSamples = [];
        let calibrationESP32PollTimer = null;
        
        // Run Check state
        let isRunningCheck = false;
        let runCheckBatch = [];
        let runCheckTimer = null;
        
        // Live Detection state
        let isLiveDetecting = false;
        let liveBatch = [];
        let liveBatchTimer = 0;
        let liveESP32PollTimer = null;
        
        // Canvas contexts
        let calibrationCanvasCtx = null;
        let liveCanvasCtx = null;
        
        // Stored profiles cache
        let machineProfiles = {};

        // ==========================================
        // INITIALIZATION
        // ==========================================
        window.addEventListener('load', function() {
            initializeCanvases();
            generateCalibrationButtons();
            loadProfiles();
            console.log("‚úÖ System initialized");
        });

        function initializeCanvases() {
            const calibCanvas = document.getElementById('calibration-canvas');
            const liveCanvas = document.getElementById('live-canvas');
            
            if (calibCanvas) {
                calibrationCanvasCtx = calibCanvas.getContext('2d');
                calibCanvas.width = calibCanvas.offsetWidth || 800;
                calibCanvas.height = calibCanvas.offsetHeight || 150;
            }
            if (liveCanvas) {
                liveCanvasCtx = liveCanvas.getContext('2d');
                liveCanvas.width = liveCanvas.offsetWidth || 800;
                liveCanvas.height = liveCanvas.offsetHeight || 150;
            }
        }

        function generateCalibrationButtons() {
            const container = document.getElementById('calibration-machines');
            const machines = ['machine_1', 'machine_2', 'machine_3'];
            
            container.innerHTML = machines.map(m => `
                <button class="listen-btn" id="listen-${m}" onclick="startListeningForMachine('${m}')" data-machine="${m}">
                    <span class="machine-name">${m.replace('_', ' ').toUpperCase()}</span>
                    <span class="profile-status" id="status-${m}">No profile</span>
                </button>
            `).join('');
        }

        // ==========================================
        // AUDIO INITIALIZATION
        // ==========================================
        async function initAudio() {
            try {
                // Check if already initialized and running
                if (audioContext && audioContext.state === 'running') {
                    console.log("‚úÖ Audio already initialized");
                    return true;
                }
                
                // Check if getUserMedia is supported
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    updateStatus('calibration', '‚ùå Your browser does not support microphone access. Try Chrome or Firefox.', 'error');
                    return false;
                }
                
                console.log("üé§ Requesting microphone permission...");
                updateStatus('calibration', 'üé§ Requesting microphone permission...', 'info');
                
                // Request microphone FIRST before creating AudioContext
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { 
                        echoCancellation: false, 
                        noiseSuppression: false, 
                        autoGainControl: false 
                    }
                });
                
                console.log("‚úÖ Microphone permission granted");
                
                // Create AudioContext after getting permission
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Resume AudioContext if suspended (required by some browsers)
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;
                analyser.minDecibels = -90;
                
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                console.log("‚úÖ Audio fully initialized");
                return true;
            } catch (error) {
                console.error("‚ùå Audio init failed:", error);
                
                // Provide specific error messages
                let errorMsg = 'Microphone error: ';
                if (error.name === 'NotAllowedError' || error.name === 'PermissionDeniedError') {
                    errorMsg = '‚ùå Microphone permission denied. Click the üîí icon in address bar ‚Üí Allow microphone.';
                } else if (error.name === 'NotFoundError') {
                    errorMsg = '‚ùå No microphone found. Please connect a microphone.';
                } else if (error.name === 'NotReadableError') {
                    errorMsg = '‚ùå Microphone is in use by another app. Close other apps using the mic.';
                } else if (error.name === 'SecurityError') {
                    errorMsg = '‚ùå Microphone blocked. Page must be served over HTTPS or localhost.';
                } else {
                    errorMsg += error.message;
                }
                
                updateStatus('calibration', errorMsg, 'error');
                return false;
            }
        }

        // ==========================================
        // CALIBRATION MODE (PER MACHINE)
        // ==========================================
        async function startListeningForMachine(machineId) {
            if (isCalibrating) {
                updateStatus('calibration', '‚ö†Ô∏è Already listening! Stop first.', 'error');
                return;
            }
            
            const ok = await initAudio();
            if (!ok) return;
            
            selectedMachine = machineId;
            isCalibrating = true;
            calibrationData = [];
            calibrationFrameCount = 0;
            calibrationTimer = 0;
            calibrationVibrationSamples = [];
            calibrationGasSamples = [];
            
            // Update UI
            document.getElementById('cal-mode-badge').textContent = 'LISTENING';
            document.getElementById('cal-mode-badge').className = 'mode-badge listening';
            document.getElementById('cal-active-machine').textContent = machineId.replace('_', ' ').toUpperCase();
            document.getElementById('calibration-control-panel').style.display = 'block';
            document.getElementById('calibration-waveform-container').style.display = 'block';
            document.getElementById('calibration-save').disabled = true;
            
            // Highlight active button
            document.querySelectorAll('.listen-btn').forEach(btn => {
                btn.classList.remove('listening');
                btn.disabled = true;
            });
            document.getElementById('listen-' + machineId).classList.add('listening');
            
            updateStatus('calibration', `üé§ Listening for ${machineId.replace('_', ' ').toUpperCase()}... Make steady sounds!`);
            
            // Start ESP32 polling during calibration
            startCalibrationESP32Polling();
            
            calibrationLoop();
        }

        function calibrationLoop() {
            if (!isCalibrating) return;
            
            const timeDomainData = new Uint8Array(analyser.frequencyBinCount);
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            
            analyser.getByteTimeDomainData(timeDomainData);
            analyser.getByteFrequencyData(frequencyData);
            
            let sum = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const val = (timeDomainData[i] - 128) / 128;
                sum += val * val;
            }
            const amplitude = Math.sqrt(sum / timeDomainData.length) * 100;
            
            let maxVal = 0, maxIndex = 0;
            for (let i = 1; i < frequencyData.length; i++) {
                if (frequencyData[i] > maxVal) {
                    maxVal = frequencyData[i];
                    maxIndex = i;
                }
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const dominantFreq = (maxIndex / frequencyData.length) * nyquist;
            const freqConfidence = maxVal / 255;
            
            // ‚úÖ FIXED: Extract TOP 5 peaks instead of just 1
            const peaks = extractTopPeaks(frequencyData, nyquist, 5);
            
            calibrationFrameCount++;
            
            // ‚úÖ NEW: Collect ALL frames locally, send only at the end
            calibrationData.push({
                amplitude,
                peaks: peaks,  // ‚úÖ Now includes multiple peaks
                timestamp: Date.now()
            });

            // Count valid frames for UI
            if (amplitude >= AMPLITUDE_THRESHOLD && freqConfidence >= CONFIDENCE_THRESHOLD) {
                calibrationValidFrames++;
            }
            
            document.getElementById('cal-duration').textContent = `${Math.floor(calibrationTimer)}s / ${CALIBRATION_DURATION}s`;
            document.getElementById('cal-frames').textContent = calibrationFrameCount;
            document.getElementById('cal-valid-frames').textContent = calibrationValidFrames;
            document.getElementById('calibration-timer').textContent = `${Math.floor(calibrationTimer)}s`;
            
            drawWaveform(timeDomainData, calibrationCanvasCtx);
            
            calibrationTimer += 0.1;
            
            if (calibrationTimer >= CALIBRATION_DURATION) {
                stopCalibration();
            } else {
                setTimeout(calibrationLoop, 100);
            }
        }

        async function stopCalibration() {
            isCalibrating = false;
            document.getElementById('calibration-start').disabled = false;
            document.getElementById('calibration-stop').disabled = true;
            document.getElementById('calibration-timer').style.display = 'none';
            
            if (calibrationValidFrames > 0) {
                updateStatus('calibration', `üì§ Uploading ${calibrationData.length} frames...`, 'info');
                
                try {
                    // ‚úÖ NEW: Send all frames as a batch
                    const response = await fetch(BACKEND_URL + '/ingest', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            frames: calibrationData,
                            machine_id: selectedMachine,
                            mode: 'calibration',
                            store_all: true,               // üî• REQUIRED
                            frames_captured: calibrationData.length
                        })

                    });
                    
                    const result = await response.json();
                    
                    if (result.status === 'calibration_batch_saved') {
                        updateStatus('calibration', `‚úÖ Batch uploaded! ${result.frames_inserted}/${result.frames_received} frames saved.`, 'success');
                        document.getElementById('calibration-save').disabled = false;
                    } else {
                        updateStatus('calibration', `Error uploading batch: ${result.error}`, 'error');
                    }
                } catch (error) {
                    updateStatus('calibration', `Error uploading: ${error.message}`, 'error');
                }
            } else {
                updateStatus('calibration', '‚ö†Ô∏è No valid frames captured. Try again with more audible sound.', 'error');
            }
        }

        async function saveProfile() {
            if (calibrationValidFrames < 10) {
                updateStatus('calibration', 'Need at least 10 valid frames!', 'error');
                return;
            }
            
            try {
                const response = await fetch(BACKEND_URL + '/save_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ machine_id: selectedMachine })
                });
                
                const result = await response.json();
                
                if (result.status === 'profile_saved') {
                    updateStatus('calibration', `‚úÖ Profile saved! Mean: ${result.mean_freq} Hz`, 'success');
                    document.getElementById('calibration-save').disabled = true;
                    loadProfiles();
                } else {
                    updateStatus('calibration', `Error: ${result.error}`, 'error');
                }
            } catch (error) {
                updateStatus('calibration', `Error: ${error.message}`, 'error');
            }
        }

        // ==========================================
        // DETECTION MODE
        // ==========================================
        async function startDetection() {
            const ok = await initAudio();
            if (!ok) return;
            
            isRunning = true;
            document.getElementById('detection-start').disabled = true;
            document.getElementById('detection-stop').disabled = false;
            updateStatus('detection', 'üé§ Listening for machines...');
            detectionLoop();
        }

        function detectionLoop() {
            if (!isRunning) return;
            
            const timeDomainData = new Uint8Array(analyser.frequencyBinCount);
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            
            analyser.getByteTimeDomainData(timeDomainData);
            analyser.getByteFrequencyData(frequencyData);
            
            let sum = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const val = (timeDomainData[i] - 128) / 128;
                sum += val * val;
            }
            const amplitude = Math.sqrt(sum / timeDomainData.length) * 100;
            
            let maxVal = 0, maxIndex = 0;
            for (let i = 1; i < frequencyData.length; i++) {
                if (frequencyData[i] > maxVal) {
                    maxVal = frequencyData[i];
                    maxIndex = i;
                }
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const dominantFreq = (maxIndex / frequencyData.length) * nyquist;
            const freqConfidence = maxVal / 255;
            
            // ‚úÖ FIXED: Extract TOP 5 peaks instead of just dominant
            const peaks = extractTopPeaks(frequencyData, nyquist, 5);
            
            // ‚úÖ NEW: Collect frames locally in a batch
            detectionBatch.push({
                amplitude,
                peaks: peaks,  // ‚úÖ Now includes multiple peaks for multi-band detection
                dominant_freq: dominantFreq,
                freq_confidence: freqConfidence,
                timestamp: Date.now()
            });
            
            document.getElementById('det-freq').textContent = dominantFreq.toFixed(1) + ' Hz';
            document.getElementById('det-amp').textContent = amplitude.toFixed(2);
            document.getElementById('det-conf').textContent = freqConfidence.toFixed(3);
            
            drawWaveform(timeDomainData, detectionCanvasCtx);
            
            // ‚úÖ NEW: Send batch every 500ms instead of 100ms (5x reduction in requests)
            detectionBatchTimer += 0.1;
            if (detectionBatchTimer >= 0.5) {
                if (detectionBatch.length > 0) {
                    fetch(BACKEND_URL + '/ingest', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            frames: detectionBatch,
                            mode: 'live'
                        })
                    })
                    .then(res => res.json())
                    .then(d => {
                        const statusEl = document.getElementById('active-machine');
                        // ‚úÖ FIXED: Read running_machines array instead of detected_machine
                        if (d.running_machines && d.running_machines.length > 0) {
                            const machineNames = d.running_machines.map(m => 
                                m.replace('_', ' ').toUpperCase()
                            ).join(', ');
                            statusEl.textContent = `üéµ ${machineNames}`;
                            statusEl.classList.add('active');
                        } else {
                            statusEl.textContent = 'No machine detected';
                            statusEl.classList.remove('active');
                        }
                    })
                    .catch(err => console.warn('Detection error:', err.message));
                }
                detectionBatch = [];
                detectionBatchTimer = 0;
            }
            
            setTimeout(detectionLoop, 100);
        }

        function stopDetection() {
            isRunning = false;
            detectionBatch = [];  // ‚úÖ NEW: Clear batch on stop
            detectionBatchTimer = 0;
            document.getElementById('detection-start').disabled = false;
            document.getElementById('detection-stop').disabled = true;
            document.getElementById('active-machine').classList.remove('active');
            updateStatus('detection', 'Stopped listening.');
        }

        // ==========================================
        // PROFILES
        // ==========================================
        async function loadProfiles() {
            try {
                const response = await fetch(BACKEND_URL + '/profiles');
                const profiles = await response.json();
                
                const container = document.getElementById('profiles-list');
                
                if (profiles.length === 0) {
                    container.innerHTML = '<p style="color: #888;">No profiles trained yet.</p>';
                    return;
                }
                
                container.innerHTML = profiles.map(p => `
                    <div class="profile-card">
                        <div class="profile-header">
                            <span>${p.machine_id.replace('_', ' ').toUpperCase()}</span>
                            <button class="delete-btn" onclick="deleteProfile('${p.machine_id}')">üóëÔ∏è Delete</button>
                        </div>
                        <div class="profile-detail">
                            <span>Median Frequency:</span>
                            <strong>${p.median_freq} Hz</strong>
                        </div>
                        <div class="profile-detail">
                            <span>Overall IQR Range:</span>
                            <strong>${p.iqr_low} ‚Äì ${p.iqr_high} Hz</strong>
                        </div>
                        <div class="profile-detail">
                            <span>Bandwidth (IQR):</span>
                            <strong>${p.iqr} Hz</strong>
                        </div>
                        <div class="profile-detail">
                            <span>Frequency Bands:</span>
                            <strong>${p.bands_count || 0} bands</strong>
                        </div>
                        ${p.freq_bands && p.freq_bands.length > 0 ? `
                            <div style="margin-top: 10px; padding: 10px; background: #0f1419; border-radius: 5px;">
                                <div style="color: #888; margin-bottom: 5px; font-size: 12px;">Detected Harmonic Bands:</div>
                                ${p.freq_bands.map((b, i) => `
                                    <div style="font-size: 12px; color: #22c55e; padding: 2px 0;">
                                        Band ${i+1}: ${b.low.toFixed(0)} ‚Äì ${b.high.toFixed(0)} Hz (center: ${b.center.toFixed(0)} Hz)
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading profiles:', error);
            }
        }

        async function deleteProfile(machineId) {
            if (!confirm(`Delete profile for ${machineId.replace('_', ' ').toUpperCase()}?`)) {
                return;
            }
            
            try {
                const response = await fetch(BACKEND_URL + '/delete_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ machine_id: machineId })
                });
                
                const result = await response.json();
                
                if (result.status === 'profile_deleted') {
                    alert(`‚úÖ Profile deleted: ${machineId}`);
                    loadProfiles();  // Refresh list
                } else {
                    alert(`‚ùå Error: ${result.error}`);
                }
            } catch (error) {
                alert(`Error deleting profile: ${error.message}`);
            }
        }

        // ==========================================
        // HELPERS
        // ==========================================
        function drawWaveform(data, ctx) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < data.length; i++) {
                const x = (i / data.length) * ctx.canvas.width;
                const y = ctx.canvas.height - ((data[i] / 255) * ctx.canvas.height);
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // ==========================================
        // PEAK EXTRACTION (NEW - CRITICAL FOR MULTI-MACHINE)
        // ==========================================
        /**
         * Extract top N peaks from frequency data.
         * Uses local maxima detection with minimum separation.
         * @param {Uint8Array} frequencyData - FFT frequency bins
         * @param {number} nyquist - Nyquist frequency (sampleRate/2)
         * @param {number} numPeaks - Number of peaks to extract (default 5)
         * @returns {Array} Array of {freq, amp} objects sorted by amplitude (descending)
         */
        function extractTopPeaks(frequencyData, nyquist, numPeaks = 5) {
            const peaks = [];
            const minSeparation = 5; // Minimum bin separation between peaks
            const minAmplitude = 10; // Minimum raw FFT value to consider (0-255) - lowered to capture quieter sounds
            
            // Find all local maxima
            for (let i = 2; i < frequencyData.length - 2; i++) {
                const val = frequencyData[i];
                
                // Skip if below minimum amplitude
                if (val < minAmplitude) continue;
                
                // Check if local maximum (higher than neighbors)
                if (val > frequencyData[i-1] && 
                    val > frequencyData[i+1] &&
                    val >= frequencyData[i-2] && 
                    val >= frequencyData[i+2]) {
                    
                    const freq = (i / frequencyData.length) * nyquist;
                    const amp = val / 255; // Normalize to 0-1
                    
                    peaks.push({ freq, amp, bin: i });
                }
            }
            
            // Sort by amplitude (descending)
            peaks.sort((a, b) => b.amp - a.amp);
            
            // Select top peaks with minimum separation
            const selectedPeaks = [];
            for (const peak of peaks) {
                // Check if far enough from already selected peaks
                let tooClose = false;
                for (const selected of selectedPeaks) {
                    if (Math.abs(peak.bin - selected.bin) < minSeparation) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    selectedPeaks.push({ freq: peak.freq, amp: peak.amp });
                    if (selectedPeaks.length >= numPeaks) break;
                }
            }
            
            return selectedPeaks;
        }

        function switchTab(event, tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            
            document.getElementById(tab).classList.add('active');
            event.target.classList.add('active');
            
            // Start/stop ESP32 polling based on tab
            if (tab === 'esp32') {
                startESP32Polling();
            } else {
                stopESP32Polling();
            }
        }

        function updateStatus(tab, message, type = 'info') {
            const el = document.getElementById(tab + '-status');
            if (el) {
                el.textContent = message;
                el.className = 'status ' + type;
            }
        }

        // ==========================================
        // ESP32 MONITOR (READ-ONLY)
        // ==========================================
        let esp32PollTimer = null;

        async function fetchESP32Data() {
            try {
                // Fetch latest ESP32 sensor data
                const esp32Res = await fetch(BACKEND_URL + '/latest_esp32');
                const esp32Data = await esp32Res.json();
                
                // Fetch live machine detection status
                const statusRes = await fetch(BACKEND_URL + '/live_status');
                const statusData = await statusRes.json();
                
                // Update ESP32 sensor display
                document.getElementById('esp32-device-id').textContent = esp32Data.device_id || '--';
                
                // Vibration display
                const vibEl = document.getElementById('esp32-vibration');
                if (esp32Data.vibration && esp32Data.vibration > 0) {
                    vibEl.textContent = 'ON';
                    vibEl.style.color = '#22c55e';
                } else {
                    vibEl.textContent = 'OFF';
                    vibEl.style.color = '#888';
                }
                
                // Gas raw value
                document.getElementById('esp32-gas-raw').textContent = esp32Data.gas_raw || 0;
                
                // Gas status with color
                const gasStatusEl = document.getElementById('esp32-gas-status');
                const gasStatus = esp32Data.gas_status || 'UNKNOWN';
                gasStatusEl.textContent = gasStatus;
                if (gasStatus === 'RISK' || gasStatus === 'DANGER') {
                    gasStatusEl.style.color = '#ef4444';
                } else if (gasStatus === 'WARNING') {
                    gasStatusEl.style.color = '#eab308';
                } else {
                    gasStatusEl.style.color = '#22c55e';
                }
                
                // Event count
                document.getElementById('esp32-event-count').textContent = esp32Data.event_count || 0;
                
                // Timestamp
                if (esp32Data.timestamp) {
                    const date = new Date(esp32Data.timestamp);
                    document.getElementById('esp32-timestamp').textContent = date.toLocaleTimeString();
                }
                
                // Machine detection
                const detected = statusData.detected || [];
                const stable = statusData.stable || [];
                
                document.getElementById('esp32-detected').textContent = 
                    detected.length > 0 ? detected.join(', ') : 'None';
                document.getElementById('esp32-stable').textContent = 
                    stable.length > 0 ? stable.join(', ') : 'None';
                
                // Update status
                updateStatus('esp32', '‚úÖ Connected - Data received', 'success');
                
            } catch (error) {
                console.error('ESP32 fetch error:', error);
                updateStatus('esp32', '‚ùå Connection error: ' + error.message, 'error');
            }
        }

        function startESP32Polling() {
            if (esp32PollTimer) return; // Already polling
            
            fetchESP32Data(); // Initial fetch
            esp32PollTimer = setInterval(fetchESP32Data, 2000);
            console.log('ESP32 polling started');
        }

        function stopESP32Polling() {
            if (esp32PollTimer) {
                clearInterval(esp32PollTimer);
                esp32PollTimer = null;
                console.log('ESP32 polling stopped');
            }
        }
    </script>
</body>
</html>