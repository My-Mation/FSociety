<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Sound Calibration & Detection</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #0f1419;
            color: #e0e0e0;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            padding: 20px;
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            color: #22c55e;
        }
        
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 30px;
            border-bottom: 2px solid #333;
        }
        
        .tab-btn {
            padding: 12px 24px;
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 16px;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        
        .tab-btn.active {
            color: #22c55e;
            border-bottom-color: #22c55e;
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .machines-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }
        
        .machine-btn {
            padding: 20px;
            background: #1a2332;
            border: 2px solid #333;
            color: #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: bold;
            transition: all 0.3s;
        }
        
        .machine-btn:hover {
            border-color: #22c55e;
            background: #1f2a38;
        }
        
        .machine-btn.selected {
            background: #22c55e;
            color: #000;
            border-color: #22c55e;
        }
        
        .control-panel {
            background: #1a2332;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .info-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            padding: 10px;
            background: #0f1419;
            border-radius: 5px;
        }
        
        .info-label {
            font-weight: bold;
            color: #888;
        }
        
        .info-value {
            color: #22c55e;
            font-weight: bold;
            font-size: 18px;
        }
        
        button {
            padding: 10px 20px;
            background: #22c55e;
            border: none;
            color: #000;
            border-radius: 5px;
            cursor: pointer;
            font-weight: bold;
            font-size: 14px;
            transition: all 0.3s;
            margin-right: 10px;
        }
        
        button:hover {
            background: #1ea850;
        }
        
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        
        .stop-btn {
            background: #ef4444;
            color: white;
        }
        
        .stop-btn:hover {
            background: #dc2626;
        }
        
        canvas {
            width: 100%;
            height: 300px;
            background: #000;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        
        .status {
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-weight: bold;
        }
        
        .status.info {
            background: #1e3a8a;
            color: #93c5fd;
        }
        
        .status.success {
            background: #166534;
            color: #86efac;
        }
        
        .status.error {
            background: #7f1d1d;
            color: #fca5a5;
        }
        
        .profiles-list {
            display: grid;
            gap: 15px;
        }
        
        .profile-card {
            background: #1a2332;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #22c55e;
        }
        
        .profile-header {
            font-size: 18px;
            font-weight: bold;
            color: #22c55e;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .delete-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s;
        }
        
        .delete-btn:hover {
            background: #dc2626;
        }
        
        .profile-detail {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #333;
            margin-bottom: 5px;
        }
        
        .detection-status {
            font-size: 24px;
            font-weight: bold;
            padding: 20px;
            text-align: center;
            background: #1a2332;
            border-radius: 8px;
            margin-bottom: 20px;
            min-height: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .detection-status.active {
            background: #166534;
            color: #86efac;
        }
        
        .timer {
            font-size: 32px;
            font-weight: bold;
            text-align: center;
            color: #22c55e;
            margin: 20px 0;
        }
        
        h3 {
            margin-top: 20px;
            margin-bottom: 15px;
            color: #e0e0e0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üéµ Machine Sound Calibration & Detection</h1>
        
        <div class="tabs">
            <button class="tab-btn active" onclick="switchTab(event, 'calibration')">üìä Calibration</button>
            <button class="tab-btn" onclick="switchTab(event, 'detection')">üîç Live Detection</button>
            <button class="tab-btn" onclick="switchTab(event, 'profiles')">‚öôÔ∏è Profiles</button>
        </div>
        
        <!-- ===== CALIBRATION TAB ===== -->
        <div id="calibration" class="tab-content active">
            <div class="status info" id="calibration-status">Select a machine and click to calibrate</div>
            
            <h3>Select Machine to Calibrate:</h3>
            <div class="machines-grid" id="calibration-machines"></div>
            
            <div class="control-panel">
                <div class="info-row">
                    <span class="info-label">Recording Duration:</span>
                    <span class="info-value" id="cal-duration">0s / 60s</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Frames Captured:</span>
                    <span class="info-value" id="cal-frames">0</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Valid Frames:</span>
                    <span class="info-value" id="cal-valid-frames">0</span>
                </div>
                <div class="timer" id="calibration-timer" style="display:none;">0s</div>
                <button id="calibration-start" onclick="startCalibration()">üé§ Start Calibration</button>
                <button id="calibration-stop" class="stop-btn" onclick="stopCalibration()" disabled>‚èπÔ∏è Stop</button>
                <button id="calibration-save" onclick="saveProfile()" disabled style="background: #3b82f6;">üíæ Save Profile</button>
            </div>
            
            <h3>Waveform & Frequency:</h3>
            <canvas id="calibration-canvas"></canvas>
        </div>
        
        <!-- ===== DETECTION TAB ===== -->
        <div id="detection" class="tab-content">
            <div class="status info" id="detection-status">Click Start to begin listening</div>
            
            <div class="detection-status" id="active-machine">No machine detected</div>
            
            <div class="control-panel">
                <div class="info-row">
                    <span class="info-label">Detected Frequency:</span>
                    <span class="info-value" id="det-freq">-- Hz</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Amplitude:</span>
                    <span class="info-value" id="det-amp">--</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Confidence:</span>
                    <span class="info-value" id="det-conf">--</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Detect Confidence:</span>
                    <span class="info-value" id="det-detect-conf">--</span>
                </div>
                <div class="info-row">
                    <span class="info-label">Anomaly:</span>
                    <span class="info-value" id="det-anomaly">--</span>
                </div>
                
                <button id="detection-start" onclick="startDetection()">üé§ Start Listening</button>
                <button id="detection-stop" class="stop-btn" onclick="stopDetection()" disabled>‚èπÔ∏è Stop</button>
            </div>
            
            <h3>Live Waveform:</h3>
            <canvas id="detection-canvas"></canvas>
        </div>
        
        <!-- ===== PROFILES TAB ===== -->
        <div id="profiles" class="tab-content">
            <button onclick="loadProfiles()" style="margin-bottom: 20px;">üîÑ Refresh Profiles</button>
            <div id="profiles-list" class="profiles-list">
                <p style="color: #888;">Loading profiles...</p>
            </div>
        </div>
    </div>

    <script>
        // ==========================================
        // CONFIGURATION
        // ==========================================
        const BACKEND_URL = `${window.location.origin}`;
        const CALIBRATION_DURATION = 60;
        // ‚úÖ FIXED: Lowered thresholds to capture normal sounds
        // Amplitude is 0-100 scale, so 0.5 = very quiet sounds
        const AMPLITUDE_THRESHOLD = 0.5;
        // Confidence is 0-1 scale, 0.08 = any detectable frequency peak
        const CONFIDENCE_THRESHOLD = 0.08;
        
        let audioContext = null;
        let analyser = null;
        let microphone = null;
        let isRunning = false;
        let isCalibrating = false;
        
        let calibrationData = [];
        let calibrationTimer = 0;
        let calibrationFrameCount = 0;
        let calibrationValidFrames = 0;
        let selectedMachine = null;
        
        // ‚úÖ NEW: Detection batch variables
        let detectionBatch = [];
        let detectionBatchTimer = 0;
        
        let calibrationCanvasCtx = null;
        let detectionCanvasCtx = null;

        // ==========================================
        // INITIALIZATION
        // ==========================================
        window.addEventListener('load', function() {
            initializeCanvases();
            generateMachineButtons('calibration');
            generateMachineButtons('detection');
            loadProfiles();
            console.log("‚úÖ System initialized");
        });

        function initializeCanvases() {
            const calibCanvas = document.getElementById('calibration-canvas');
            const detectionCanvas = document.getElementById('detection-canvas');
            
            calibrationCanvasCtx = calibCanvas.getContext('2d');
            detectionCanvasCtx = detectionCanvas.getContext('2d');
            
            calibCanvas.width = calibCanvas.offsetWidth;
            calibCanvas.height = calibCanvas.offsetHeight;
            detectionCanvas.width = detectionCanvas.offsetWidth;
            detectionCanvas.height = detectionCanvas.offsetHeight;
        }

        function generateMachineButtons(tab) {
            const container = document.getElementById(tab + '-machines');
            const machines = ['machine_1', 'machine_2', 'machine_3', 'machine_4'];
            
            container.innerHTML = machines.map(m => `
                <button class="machine-btn" onclick="selectMachine('${m}')" data-machine="${m}">
                    ${m.replace('_', ' ').toUpperCase()}
                </button>
            `).join('');
        }

        function selectMachine(machineId) {
            selectedMachine = machineId;
            document.querySelectorAll('[data-machine]').forEach(btn => {
                btn.classList.remove('selected');
                if (btn.getAttribute('data-machine') === machineId) {
                    btn.classList.add('selected');
                }
            });
            updateStatus('calibration', `Selected: ${machineId.replace('_', ' ').toUpperCase()}`);
        }

        // ==========================================
        // AUDIO INITIALIZATION
        // ==========================================
        async function initAudio() {
            try {
                if (audioContext && audioContext.state === 'running') return true;
                
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                analyser.smoothingTimeConstant = 0.8;
                analyser.minDecibels = -90;
                
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
                });
                
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);
                
                return true;
            } catch (error) {
                console.error("‚ùå Audio init failed:", error);
                updateStatus('calibration', 'Microphone error: ' + error.message, 'error');
                return false;
            }
        }

        // ==========================================
        // CALIBRATION MODE
        // ==========================================
        async function startCalibration() {
            if (!selectedMachine) {
                updateStatus('calibration', 'Please select a machine first!', 'error');
                return;
            }
            
            const ok = await initAudio();
            if (!ok) return;
            
            isCalibrating = true;
            calibrationData = [];
            calibrationFrameCount = 0;
            calibrationValidFrames = 0;
            calibrationTimer = 0;
            
            document.getElementById('calibration-start').disabled = true;
            document.getElementById('calibration-stop').disabled = false;
            document.getElementById('calibration-save').disabled = true;
            document.getElementById('calibration-timer').style.display = 'block';
            
            updateStatus('calibration', `üìç Calibrating ${selectedMachine}... Make steady sounds!`);
            calibrationLoop();
        }

        function calibrationLoop() {
            if (!isCalibrating) return;
            
            const timeDomainData = new Uint8Array(analyser.frequencyBinCount);
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            
            analyser.getByteTimeDomainData(timeDomainData);
            analyser.getByteFrequencyData(frequencyData);
            
            let sum = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const val = (timeDomainData[i] - 128) / 128;
                sum += val * val;
            }
            const amplitude = Math.sqrt(sum / timeDomainData.length) * 100;
            
            let maxVal = 0, maxIndex = 0;
            for (let i = 1; i < frequencyData.length; i++) {
                if (frequencyData[i] > maxVal) {
                    maxVal = frequencyData[i];
                    maxIndex = i;
                }
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const dominantFreq = (maxIndex / frequencyData.length) * nyquist;
            const freqConfidence = maxVal / 255;
            
            // ‚úÖ FIXED: Extract TOP 5 peaks instead of just 1
            const peaks = extractTopPeaks(frequencyData, nyquist, 5);
            
            calibrationFrameCount++;
            
            // ‚úÖ NEW: Collect ALL frames locally, send only at the end
            calibrationData.push({
                amplitude,
                peaks: peaks,  // ‚úÖ Now includes multiple peaks
                timestamp: Date.now()
            });

            // Count valid frames for UI
            if (amplitude >= AMPLITUDE_THRESHOLD && freqConfidence >= CONFIDENCE_THRESHOLD) {
                calibrationValidFrames++;
            }
            
            document.getElementById('cal-duration').textContent = `${Math.floor(calibrationTimer)}s / ${CALIBRATION_DURATION}s`;
            document.getElementById('cal-frames').textContent = calibrationFrameCount;
            document.getElementById('cal-valid-frames').textContent = calibrationValidFrames;
            document.getElementById('calibration-timer').textContent = `${Math.floor(calibrationTimer)}s`;
            
            drawWaveform(timeDomainData, calibrationCanvasCtx);
            
            calibrationTimer += 0.1;
            
            if (calibrationTimer >= CALIBRATION_DURATION) {
                stopCalibration();
            } else {
                setTimeout(calibrationLoop, 100);
            }
        }

        async function stopCalibration() {
            isCalibrating = false;
            document.getElementById('calibration-start').disabled = false;
            document.getElementById('calibration-stop').disabled = true;
            document.getElementById('calibration-timer').style.display = 'none';
            
            if (calibrationValidFrames > 0) {
                updateStatus('calibration', `üì§ Uploading ${calibrationData.length} frames...`, 'info');
                
                try {
                    // ‚úÖ NEW: Send all frames as a batch
                    const response = await fetch(BACKEND_URL + '/ingest', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            frames: calibrationData,
                            machine_id: selectedMachine,
                            mode: 'calibration',
                            store_all: true,               // üî• REQUIRED
                            frames_captured: calibrationData.length
                        })

                    });
                    
                    const result = await response.json();
                    
                    if (result.status === 'calibration_batch_saved') {
                        updateStatus('calibration', `‚úÖ Batch uploaded! ${result.frames_inserted}/${result.frames_received} frames saved.`, 'success');
                        document.getElementById('calibration-save').disabled = false;
                    } else {
                        updateStatus('calibration', `Error uploading batch: ${result.error}`, 'error');
                    }
                } catch (error) {
                    updateStatus('calibration', `Error uploading: ${error.message}`, 'error');
                }
            } else {
                updateStatus('calibration', '‚ö†Ô∏è No valid frames captured. Try again with more audible sound.', 'error');
            }
        }

        async function saveProfile() {
            if (calibrationValidFrames < 10) {
                updateStatus('calibration', 'Need at least 10 valid frames!', 'error');
                return;
            }
            
            try {
                const response = await fetch(BACKEND_URL + '/save_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ machine_id: selectedMachine })
                });
                
                const result = await response.json();
                
                if (result.status === 'profile_saved') {
                    updateStatus('calibration', `‚úÖ Profile saved! Mean: ${result.mean_freq} Hz`, 'success');
                    document.getElementById('calibration-save').disabled = true;
                    loadProfiles();
                } else {
                    updateStatus('calibration', `Error: ${result.error}`, 'error');
                }
            } catch (error) {
                updateStatus('calibration', `Error: ${error.message}`, 'error');
            }
        }

        // ==========================================
        // DETECTION MODE
        // ==========================================
        async function startDetection() {
            const ok = await initAudio();
            if (!ok) return;
            
            isRunning = true;
            document.getElementById('detection-start').disabled = true;
            document.getElementById('detection-stop').disabled = false;
            updateStatus('detection', 'üé§ Listening for machines...');
            detectionLoop();
        }

        function detectionLoop() {
            if (!isRunning) return;
            
            const timeDomainData = new Uint8Array(analyser.frequencyBinCount);
            const frequencyData = new Uint8Array(analyser.frequencyBinCount);
            
            analyser.getByteTimeDomainData(timeDomainData);
            analyser.getByteFrequencyData(frequencyData);
            
            let sum = 0;
            for (let i = 0; i < timeDomainData.length; i++) {
                const val = (timeDomainData[i] - 128) / 128;
                sum += val * val;
            }
            const amplitude = Math.sqrt(sum / timeDomainData.length) * 100;
            
            let maxVal = 0, maxIndex = 0;
            for (let i = 1; i < frequencyData.length; i++) {
                if (frequencyData[i] > maxVal) {
                    maxVal = frequencyData[i];
                    maxIndex = i;
                }
            }
            
            const nyquist = audioContext.sampleRate / 2;
            const dominantFreq = (maxIndex / frequencyData.length) * nyquist;
            const freqConfidence = maxVal / 255;
            
            // ‚úÖ FIXED: Extract TOP 5 peaks instead of just dominant
            const peaks = extractTopPeaks(frequencyData, nyquist, 5);
            
            // ‚úÖ NEW: Collect frames locally in a batch
            detectionBatch.push({
                amplitude,
                peaks: peaks,  // ‚úÖ Now includes multiple peaks for multi-band detection
                dominant_freq: dominantFreq,
                freq_confidence: freqConfidence,
                timestamp: Date.now()
            });
            
            document.getElementById('det-freq').textContent = dominantFreq.toFixed(1) + ' Hz';
            document.getElementById('det-amp').textContent = amplitude.toFixed(2);
            document.getElementById('det-conf').textContent = freqConfidence.toFixed(3);
            
            drawWaveform(timeDomainData, detectionCanvasCtx);
            
            // ‚úÖ NEW: Send batch every 500ms instead of 100ms (5x reduction in requests)
            detectionBatchTimer += 0.1;
            if (detectionBatchTimer >= 0.5) {
                if (detectionBatch.length > 0) {
                    fetch(BACKEND_URL + '/ingest', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            frames: detectionBatch,
                            mode: 'live'
                        })
                    })
                    .then(res => res.json())
                    .then(d => {
                        const statusEl = document.getElementById('active-machine');
                        // ‚úÖ FIXED: Read running_machines array instead of detected_machine
                        if (d.running_machines && d.running_machines.length > 0) {
                            const machineNames = d.running_machines.map(m => 
                                m.replace('_', ' ').toUpperCase()
                            ).join(', ');
                            statusEl.textContent = `üéµ ${machineNames}`;
                            statusEl.classList.add('active');
                        } else {
                            statusEl.textContent = 'No machine detected';
                            statusEl.classList.remove('active');
                        }
                    })
                    .catch(err => console.warn('Detection error:', err.message));
                }
                detectionBatch = [];
                detectionBatchTimer = 0;
            }
            
            setTimeout(detectionLoop, 100);
        }

        function stopDetection() {
            isRunning = false;
            detectionBatch = [];  // ‚úÖ NEW: Clear batch on stop
            detectionBatchTimer = 0;
            document.getElementById('detection-start').disabled = false;
            document.getElementById('detection-stop').disabled = true;
            document.getElementById('active-machine').classList.remove('active');
            updateStatus('detection', 'Stopped listening.');
        }

        // ==========================================
        // PROFILES
        // ==========================================
        async function loadProfiles() {
            try {
                const response = await fetch(BACKEND_URL + '/profiles');
                const profiles = await response.json();
                
                const container = document.getElementById('profiles-list');
                
                if (profiles.length === 0) {
                    container.innerHTML = '<p style="color: #888;">No profiles trained yet.</p>';
                    return;
                }
                
                container.innerHTML = profiles.map(p => `
                    <div class="profile-card">
                        <div class="profile-header">
                            <span>${p.machine_id.replace('_', ' ').toUpperCase()}</span>
                            <button class="delete-btn" onclick="deleteProfile('${p.machine_id}')">üóëÔ∏è Delete</button>
                        </div>
                        <div class="profile-detail">
                            <span>Median Frequency:</span>
                            <strong>${p.median_freq} Hz</strong>
                        </div>
                        <div class="profile-detail">
                            <span>Overall IQR Range:</span>
                            <strong>${p.iqr_low} ‚Äì ${p.iqr_high} Hz</strong>
                        </div>
                        <div class="profile-detail">
                            <span>Bandwidth (IQR):</span>
                            <strong>${p.iqr} Hz</strong>
                        </div>
                        <div class="profile-detail">
                            <span>Frequency Bands:</span>
                            <strong>${p.bands_count || 0} bands</strong>
                        </div>
                        ${p.freq_bands && p.freq_bands.length > 0 ? `
                            <div style="margin-top: 10px; padding: 10px; background: #0f1419; border-radius: 5px;">
                                <div style="color: #888; margin-bottom: 5px; font-size: 12px;">Detected Harmonic Bands:</div>
                                ${p.freq_bands.map((b, i) => `
                                    <div style="font-size: 12px; color: #22c55e; padding: 2px 0;">
                                        Band ${i+1}: ${b.low.toFixed(0)} ‚Äì ${b.high.toFixed(0)} Hz (center: ${b.center.toFixed(0)} Hz)
                                    </div>
                                `).join('')}
                            </div>
                        ` : ''}
                    </div>
                `).join('');
            } catch (error) {
                console.error('Error loading profiles:', error);
            }
        }

        async function deleteProfile(machineId) {
            if (!confirm(`Delete profile for ${machineId.replace('_', ' ').toUpperCase()}?`)) {
                return;
            }
            
            try {
                const response = await fetch(BACKEND_URL + '/delete_profile', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ machine_id: machineId })
                });
                
                const result = await response.json();
                
                if (result.status === 'profile_deleted') {
                    alert(`‚úÖ Profile deleted: ${machineId}`);
                    loadProfiles();  // Refresh list
                } else {
                    alert(`‚ùå Error: ${result.error}`);
                }
            } catch (error) {
                alert(`Error deleting profile: ${error.message}`);
            }
        }

        // ==========================================
        // HELPERS
        // ==========================================
        function drawWaveform(data, ctx) {
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
            
            ctx.strokeStyle = '#22c55e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            
            for (let i = 0; i < data.length; i++) {
                const x = (i / data.length) * ctx.canvas.width;
                const y = ctx.canvas.height - ((data[i] / 255) * ctx.canvas.height);
                i === 0 ? ctx.moveTo(x, y) : ctx.lineTo(x, y);
            }
            ctx.stroke();
        }

        // ==========================================
        // PEAK EXTRACTION (NEW - CRITICAL FOR MULTI-MACHINE)
        // ==========================================
        /**
         * Extract top N peaks from frequency data.
         * Uses local maxima detection with minimum separation.
         * @param {Uint8Array} frequencyData - FFT frequency bins
         * @param {number} nyquist - Nyquist frequency (sampleRate/2)
         * @param {number} numPeaks - Number of peaks to extract (default 5)
         * @returns {Array} Array of {freq, amp} objects sorted by amplitude (descending)
         */
        function extractTopPeaks(frequencyData, nyquist, numPeaks = 5) {
            const peaks = [];
            const minSeparation = 5; // Minimum bin separation between peaks
            const minAmplitude = 10; // Minimum raw FFT value to consider (0-255) - lowered to capture quieter sounds
            
            // Find all local maxima
            for (let i = 2; i < frequencyData.length - 2; i++) {
                const val = frequencyData[i];
                
                // Skip if below minimum amplitude
                if (val < minAmplitude) continue;
                
                // Check if local maximum (higher than neighbors)
                if (val > frequencyData[i-1] && 
                    val > frequencyData[i+1] &&
                    val >= frequencyData[i-2] && 
                    val >= frequencyData[i+2]) {
                    
                    const freq = (i / frequencyData.length) * nyquist;
                    const amp = val / 255; // Normalize to 0-1
                    
                    peaks.push({ freq, amp, bin: i });
                }
            }
            
            // Sort by amplitude (descending)
            peaks.sort((a, b) => b.amp - a.amp);
            
            // Select top peaks with minimum separation
            const selectedPeaks = [];
            for (const peak of peaks) {
                // Check if far enough from already selected peaks
                let tooClose = false;
                for (const selected of selectedPeaks) {
                    if (Math.abs(peak.bin - selected.bin) < minSeparation) {
                        tooClose = true;
                        break;
                    }
                }
                
                if (!tooClose) {
                    selectedPeaks.push({ freq: peak.freq, amp: peak.amp });
                    if (selectedPeaks.length >= numPeaks) break;
                }
            }
            
            return selectedPeaks;
        }

        function switchTab(event, tab) {
            document.querySelectorAll('.tab-content').forEach(el => el.classList.remove('active'));
            document.querySelectorAll('.tab-btn').forEach(el => el.classList.remove('active'));
            
            document.getElementById(tab).classList.add('active');
            event.target.classList.add('active');
        }

        function updateStatus(tab, message, type = 'info') {
            const el = document.getElementById(tab + '-status');
            el.textContent = message;
            el.className = 'status ' + type;
        }
    </script>
</body>
</html>
